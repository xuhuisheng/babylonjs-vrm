<!DOCTYPE html>
<html>
  <head>
    <title>vrm</title>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="./babylon-vrm-loader.js"></script>
    <style>
    html, body { width: 100%; height: 100%; padding: 0; margin: 0; overflow: hidden; }
    </style>

  </head>
  <body>
    <canvas id="renderCanvas" width="800" height ="600"></canvas>
    <script>

var createScene = function (engine, canvas) {
    const scene = new BABYLON.Scene(engine);
    const camera = new BABYLON.ArcRotateCamera("camera1", Math.PI / 2, Math.PI / 2, 4, new BABYLON.Vector3(0, 0.5, 0.4), scene);
    camera.attachControl(canvas, true);

    new BABYLON.DirectionalLight("light", new BABYLON.Vector3(0.3, -1, 0.3), scene);
    // BABYLON.MeshBuilder.CreateGround("ground", {width: 6, height: 6}, scene);

    function loadVRM(callback) {
        BABYLON.SceneLoader.Append(
            // 'https://raw.githubusercontent.com/vrm-c/UniVRM/refs/heads/master/Tests/Models/Alicia_vrm-0.51/',
            // 'AliciaSolid_vrm-0.51.vrm',
            // 'https://xuhuisheng.github.io/babylonjs-vrm/',
            './',
            'VRM1_Constraint_Twist_Sample.vrm',
            scene,
            callback
        );
    }

    function onVRMLoaded() {
        try {
            const manager = scene.metadata.vrmManagers[0];
            scene.registerBeforeRender(() => {
                // Update SpringBone
                manager.update(scene.getEngine().getDeltaTime());
            });

            loadAnimation();

        } catch (e) {
            console.log('error', e)
        }
    }

    function loadAnimation(manager) {
        BABYLON.LoadAssetContainerAsync(
            // './vrm/test.vrma',
            // './vrm/MCPM_20230806_154241.vrma',
            // './vrm/MCPM_20230806_154323.vrma',
            // './vrm/MCPM_20230806_154402.vrma',
            // './vrm/MCPM_20230806_154429.vrma',
            // './vrm/MCPM_20230806_154455.vrma',
            './VRMA_01.vrma',
            // './vrm/VRMA_02.vrma',
            // './vrm/VRMA_03.vrma',
            // './vrm/different_pose.vrma',
            scene
        ).then((assetContainer) => {
            // console.log(assetContainer)

            let vrmAnimationManager = scene.metadata.vrmAnimationManagers[0];

            let animationGroup = assetContainer.animationGroups[0]
            let animation = animationGroup.targetedAnimations[0].animation

            const newAnimationGroup = new BABYLON.AnimationGroup("new-animation-group");

            animationGroup.targetedAnimations.forEach((animation, indexAnimation) => {
                let boneName = scene.metadata.vrmAnimationManagers[0].animationMap.get(indexAnimation)

                if (true
                        && boneName != 'hips'
                        // && boneName != 'spine'
                        // && boneName != 'chest'
                        // && boneName != 'upperChest'
                        // && boneName != 'leftShoulder'
                        // && boneName != 'leftLowerArm'
                        // && boneName != 'leftUpperArm'
                        // && boneName != 'leftHand'
                        // && boneName != 'rightShoulder'
                        // && boneName != 'rightLowerArm'
                        // && boneName != 'rightUpperArm'
                        // && boneName != 'rightHand'
                        && boneName != 'leftUpperLeg'
                        // && boneName != 'leftLowerLeg'
                        // && boneName != 'leftToes'
                        && boneName != 'rightUpperLeg'
                        // && boneName != 'rightLowerLeg'
                        // && boneName != 'rightToes'
                    ) {
                    return;
                }

                function toGrade(vector3) {
                    return {
                        x: (vector3.x / Math.PI * 180).toFixed(2),
                        y: (vector3.y / Math.PI * 180).toFixed(2),
                        z: (vector3.z / Math.PI * 180).toFixed(2),
                    }
                }

                let anima = animation.animation
                // console.log(anima)
                if (anima.targetProperty == 'rotationQuaternion') {
                    let childQuaternion = vrmAnimationManager.rotationMap.get(boneName)
                    childQuaternion = childQuaternion.invert()

                    let parentName = vrmAnimationManager.parentMap.get(boneName)
                    let parentNode = vrmAnimationManager.rotationMap.get(parentName)
                    let parentQuaternion = BABYLON.Quaternion.Zero()
                    if (parentNode) {
                        parentQuaternion = parentNode
                    }

                    // console.log(boneName, toGrade(childQuaternion.toEulerAngles()), childQuaternion)
                    // console.log(boneName, toGrade(parentQuaternion.toEulerAngles()), parentQuaternion)

                    anima.getKeys().forEach((keyFrame) => {
                        let quaternion = keyFrame.value
                        if (childQuaternion) {
                            // console.log(boneName, 'before', toGrade(quaternion.toEulerAngles()), quaternion)
                            // console.log(boneName, 'after', toGrade(qua.multiply(quaternion).toEulerAngles()), qua.multiply(quaternion))

                            // quaternion = quaternion.multiply(qua)
                            // quaternion = qua.multiply(quaternion)

                            // console.log(boneName, toGrade(quaternion.toEulerAngles()), quaternion)

                            // quaternion = quaternion.multiply(parentQuaternion).multiply(childQuaternion)
                            // quaternion = quaternion.multiply(childQuaternion)
                            quaternion = childQuaternion.multiply(quaternion) //.multiply(parentQuaternion)

                            keyFrame.value = quaternion;

                        }
                    })
                } else if (anima.targetProperty == 'position') {
                    let vec = vrmAnimationManager.translationMap.get(boneName)
                    anima.getKeys().forEach((keyFrame) => {
                        let position = keyFrame.value
                        if (vec) {
                            // console.log(qua)
                            // console.log(qua.invert(), qua)
                            position = position.subtract(vec)
                            // console.log(quaternion)
                            keyFrame.value = position;
                        }
                    })
                } else {
                    console.log('unsupport', anima.targetProperty)
                }

                let bone = scene.metadata.vrmManagers[0].humanoidBone[boneName]
                if (!bone) {
                    bone = scene.meshes[0]
                }

                newAnimationGroup.addTargetedAnimation(anima, bone);
            })

            // scene.addAnimationGroup(newAnimationGroup);
            newAnimationGroup.start(true, 1.0, newAnimationGroup.from, newAnimationGroup.to, true)

        })
    }

    loadVRM(onVRMLoaded)

    return scene;
};

async function init() {
    let canvas = document.getElementById('renderCanvas')
    canvas.height = window.innerHeight 
    canvas.width = window.innerWidth
    let engine = new BABYLON.Engine(canvas, true, {preserveDrawingBuffer: true, stencil: true})

    scene = await createScene(engine, canvas)

    engine.runRenderLoop(function(){
      scene.render()
    });
}

init()


    </script>
  </body>
</html>

(()=>{var e={731:(e,t,i)=>{var n;self,n=(e,t,i,n,r,a,o,s,l,d,h,f,u,m,c,p,g,_,M)=>(()=>{"use strict";var A={908:e=>{e.exports=o},556:e=>{e.exports=f},272:e=>{e.exports=m},55:e=>{e.exports=u},677:e=>{e.exports=s},66:e=>{e.exports=l},824:e=>{e.exports=c},713:e=>{e.exports=M},221:e=>{e.exports=h},628:e=>{e.exports=p},721:e=>{e.exports=d},548:e=>{e.exports=a},694:e=>{e.exports=r},388:t=>{t.exports=e},680:e=>{e.exports=t},812:e=>{e.exports=g},474:e=>{e.exports=i},538:e=>{e.exports=n},667:e=>{e.exports=_}},v={};function I(e){var t=v[e];if(void 0!==t)return t.exports;var i=v[e]={exports:{}};return A[e](i,i.exports,I),i.exports}I.d=(e,t)=>{for(var i in t)I.o(t,i)&&!I.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},I.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),I.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var T={};return(()=>{function e(e,t,i,n){var r,a=arguments.length,o=a<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,i,n);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(o=(a<3?r(o):a>3?r(t,i,o):r(t,i))||o);return a>3&&o&&Object.defineProperty(t,i,o),o}I.r(T),I.d(T,{CullMode:()=>C,DebugMode:()=>x,MToonMaterial:()=>P,OutlineColorMode:()=>N,OutlineWidthMode:()=>D}),Object.create,Object.create;var t=I(388),i=I(680),n=I(474),r=I(538),a=I(694),o=I(548),s=I(908),l=I(677),d=I(66),h=I(721),f=I(221),u=I(556),m=I(55),c=I(272),p=I(824),g=I(628),_=I(812),M=I(667);class A{constructor(e,t){this.scene=e,this.material=t,this.name=`MToonOutline_${t.name}_${A.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine(),this._passIdForDrawWrapper=[];for(let e=0;e<1;++e)this._passIdForDrawWrapper[e]=this._engine.createRenderPassId(`Outline Renderer (${e})`)}register(){this.scene._afterRenderingMeshStage.registerStep(M.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){for(let e=0;e<this._passIdForDrawWrapper.length;++e)this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e])}render(e,t,i){i=null!=i?i:this._passIdForDrawWrapper[0];const n=this.scene,r=e.effect;if(!r||!r.isReady()||!this.scene.activeCamera)return;const a=e._getDrawWrapper(i,!0);if(!a)return;if(a.setEffect(r),!a.effect||!a.effect.isReady())return;const o=e.getMesh(),s=o._internalAbstractMeshDataInfo._actAsRegularMesh?o:null,l=e.getRenderingMesh(),d=s||l;n.activeCamera&&(this.material.applyOutlineCullMode(),this.material.enableOutlineRender(),this._engine.enableEffect(a),this.isHardwareInstancedRendering(e,t)||l._bind(e,r,this.material.fillMode),this.material._preBind(r),l._processRendering(d,e,r,this.material.fillMode,t,this.isHardwareInstancedRendering(e,t),((t,i,n)=>{n&&n.bindForSubMesh(i,d,e)}),this.material),this.material.restoreOutlineCullMode(),this.material.disaableOutlineRender())}_afterRenderingMesh(e,t,i){if(!this.willRender(t))return;const n=this._engine.cullBackFaces;this._engine.cullBackFaces=!1,this.render(t,i,this._passIdForDrawWrapper[0]),this._engine.cullBackFaces=n}isHardwareInstancedRendering(e,t){return!!this._engine.getCaps().instancedArrays&&null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]&&e.getRenderingMesh().hasThinInstances}willRender(e){const t=e.getMaterial();return!(!t||"MToonMaterial"!==t.getClassName()||t.getOutlineRendererName()!==this.name)}}A.rendererId=0;var v=I(713);class S extends v.MaterialDefines{constructor(e){super(e),this.CUSTOMUSERLIGHTING=!0,this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.BUMP=!1,this.BUMPDIRECTUV=0,this.PARALLAX=!1,this.PARALLAXOCCLUSION=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.NORMAL=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_POSITION=!0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=0,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.DITHER=!1,this.IS_REFLECTION_LINEAR=!1,this.IS_REFRACTION_LINEAR=!1,this.EXPOSURE=!1,this.FLIP_U=!1,this.FLIP_V=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}const E={effect:null,subMesh:null};var x,N,D,C;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(x||(x={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(N||(N={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(D||(D={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(C||(C={}));class P extends h.PushMaterial{constructor(e,t){super(e,t),this._diffuseTexture=null,this.diffuseTexture=null,this._emissiveTexture=null,this.emissiveTexture=null,this._bumpTexture=null,this.bumpTexture=null,this._shadeTexture=null,this.shadeTexture=null,this._receiveShadowTexture=null,this.receiveShadowTexture=null,this._shadingGradeTexture=null,this.shadingGradeTexture=null,this._rimTexture=null,this.rimTexture=null,this._matCapTexture=null,this.matCapTexture=null,this._outlineWidthTexture=null,this.outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.uvAnimationMaskTexture=null,this.diffuseColor=new o.Color3(1,1,1),this.ambientColor=new o.Color3(0,0,0),this.emissiveColor=new o.Color3(0,0,0),this.shadeColor=new o.Color3(.97,.81,.86),this.rimColor=new o.Color3(0,0,0),this.outlineColor=new o.Color3(0,0,0),this.useEmissiveAsIllumination=!1,this.linkEmissiveWithDiffuse=!1,this.useReflectionOverAlpha=!1,this._disableLighting=!1,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.specularSupported=!1,this.useLightmapAsShadowmap=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.useBakedVertexAnimation=!1,this.alphaCutOff=.4,this._useAlphaFromDiffuseTexture=!0,this._maxSimultaneousLights=4,this._invertNormalMapX=!0,this._invertNormalMapY=!0,this._twoSidedLighting=!1,this._renderTargets=new n.SmartArray(16),this._worldViewProjectionMatrix=a.Matrix.Zero(),this._globalAmbientColor=new o.Color3(0,0,0),this._cacheHasRenderTargetTextures=!1,this._bumpScale=1,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._alphaTest=!1,this._alphaBlend=!1,this._debugMode=x.None,this.debugMode=x.None,this._outlineWidthMode=D.None,this.isOutline=0,this.outlineColorMode=N.MixedLighting,this._cullMode=C.Back,this._outlineCullMode=C.Front,this.outlineCullMode=C.Front,this.storedCullMode=C.Back,this.flipU=!1,this.flipV=!1,this.detailMap=new p.DetailMapConfiguration(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),c.Effect.IncludesShadersStore.mtoonUboDeclaration||(c.Effect.IncludesShadersStore.mtoonUboDeclaration="// it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n\n    vec3 vEyeUp;\n    float alphaCutOff;\n    vec3 vAmbientColor;\n    float aspect;\n    float isOutline;\n    vec4 time;\n};\n\n// babylon specific\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n",c.Effect.IncludesShadersStore.mtoonVertexDeclaration="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform mat4 projection;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float isOutline;\nuniform float aspect;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n",c.Effect.IncludesShadersStore.mtoonFragmentDeclaration="uniform vec4 vEyePosition;\n\n// Colors\nuniform vec4 vDiffuseColor;\nuniform vec3 vEmissiveColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\nuniform vec3 vAmbientColor;\n\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float alphaCutOff;\nuniform float visibility;\nuniform float isOutline;\nuniform vec4 time;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n",c.Effect.IncludesShadersStore.mtoonFragmentFunctions="\n/**\n* Compute Directional or Point light direction\n*/\nvec3 computeLightDirection(vec4 lightData) {\n    return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* Compute Spot Light direction\n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n    return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* Compute Hemispheric light direction\n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n    return normalize(lightData.xyz);\n}\n\n/**\n* Compute MToon diffuse lighting\n*/\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    float _dotNL = dot(lightDirection, worldNormal);\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n#ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n#else\n    // base light does not darken.\n#endif\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n    _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n    _col += mix(_emission, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n    // debug\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n",c.Effect.IncludesShadersStore.mtoonLightFragment="#ifdef LIGHT{X}\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n        //No light calculation\n    #else\n        #ifdef PBR\n            // Compute Pre Lighting infos\n            #ifdef SPOTLIGHT{X}\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo = computeHemisphericPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo = computeDirectionalPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #endif\n\n            preInfo.NdotV = NdotV;\n\n            // Compute Attenuation infos\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation = 1.0;\n            #endif\n\n            // Simulates Light radius for diffuse and spec term\n            // clear coat is using a dedicated roughness\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness = roughness;\n            #else\n                preInfo.roughness = adjustRoughnessFromLightProperties(roughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n            #endif\n\n            // Diffuse contribution\n            #ifdef HEMILIGHT{X}\n                info.diffuse = computeHemisphericDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb, light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse = computeDiffuseAndTransmittedLighting(preInfo, light{X}.vLightDiffuse.rgb, subSurfaceOut.transmittance);\n            #else\n                info.diffuse = computeDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Specular contribution\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                    info.specular = computeAnisotropicSpecularLighting(preInfo, viewDirectionW, normalW, anisotropicOut.anisotropicTangent, anisotropicOut.anisotropicBitangent, anisotropicOut.anisotropy, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #else\n                    info.specular = computeSpecularLighting(preInfo, normalW, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            // Sheen contribution\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n                    // BE Carefull: Sheen intensity is replacing the roughness value.\n                    preInfo.roughness = sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                        preInfo.roughness = sheenOut.sheenRoughness;\n                    #else\n                        preInfo.roughness = adjustRoughnessFromLightProperties(sheenOut.sheenRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen = computeSheenLighting(preInfo, normalW, sheenOut.sheenColor, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Clear Coat contribution\n            #ifdef CLEARCOAT\n                // Simulates Light radius\n                #ifdef HEMILIGHT{X}\n                    preInfo.roughness = clearcoatOut.clearCoatRoughness;\n                #else\n                    preInfo.roughness = adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                #endif\n\n                info.clearCoat = computeClearCoatLighting(preInfo, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatAARoughnessFactors.x, clearcoatOut.clearCoatIntensity, light{X}.vLightDiffuse.rgb);\n\n                #ifdef CLEARCOAT_TINT\n                    // Absorption\n                    absorption = computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract, preInfo.L, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatColor, clearcoatOut.clearCoatThickness, clearcoatOut.clearCoatIntensity);\n                    info.diffuse *= absorption;\n                    #ifdef SPECULARTERM\n                        info.specular *= absorption;\n                    #endif\n                #endif\n\n                // Apply energy conservation on diffuse and specular term.\n                info.diffuse *= info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular *= info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen *= info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info = computeSpotLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDirection, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #elif defined(HEMILIGHT{X})\n                info = computeHemisphericLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightGround, glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info = computeLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #endif\n        #endif\n\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse *= computeProjectionTextureDiffuseLighting(projectionLightSampler{X}, textureProjectionMatrix{X});\n        #endif\n    #endif\n\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i = 0; i < SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X} = viewFrustumZ{X}[i] + vPositionFromCamera{X}.z;\n                #else\n                    diff{X} = viewFrustumZ{X}[i] - vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X} >= 0.) {\n                    index{X} = i;\n                    break;\n                }\n            }\n\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X} >= 0)\n            #endif\n            {\n                #if defined(SHADOWPCF{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #else\n                        shadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #endif\n                #elif defined(SHADOWPCSS{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #else\n                        shadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #endif\n                #else\n                    shadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                #endif\n\n                #ifdef SHADOWCSMDEBUG{X}\n                    shadowDebug{X} = vec3(shadow) * vCascadeColorsMultiplier{X}[index{X}];\n                #endif\n\n                #ifndef SHADOWCSMNOBLEND{X}\n                    float frustumLength = frustumLengths{X}[index{X}];\n                    float diffRatio = clamp(diff{X} / frustumLength, 0., 1.) * cascadeBlendFactor{X};\n                    if (index{X} < (SHADOWCSMNUM_CASCADES{X} - 1) && diffRatio < 1.)\n                    {\n                        index{X} += 1;\n                        float nextShadow = 0.;\n                        #if defined(SHADOWPCF{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #else\n                                nextShadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #endif\n                        #elif defined(SHADOWPCSS{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #else\n                                nextShadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #endif\n                        #else\n                            nextShadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                        #endif\n\n                        shadow = mix(nextShadow, shadow, diffRatio);\n                        #ifdef SHADOWCSMDEBUG{X}\n                            shadowDebug{X} = mix(vec3(nextShadow) * vCascadeColorsMultiplier{X}[index{X}], shadowDebug{X}, diffRatio);\n                        #endif\n                    }\n                #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow += shadow;\n            shadowLightCount += 1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            // Compute and reflect MToon lighting\n            #ifdef SPOTLIGHT{X}\n                lightDirection = computeSpotLightDirection(light{X}.vLightData);\n            #elif defined(HEMILIGHT{X})\n                lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                lightDirection = computeLightDirection(light{X}.vLightData);\n            #endif\n            mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n            diffuseBase += mtoonDiffuse.rgb;\n            alpha = min(alpha, mtoonDiffuse.a);\n            #if defined(ALPHATEST) && ALPHATEST\n                alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n                if (alpha < alphaCutOff) {\n                    discard;\n                }\n                alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n            #else\n                if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n                    discard;\n                }\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase += lightmapColor.rgb * shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase += info.specular * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase += info.clearCoat.rgb * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase += info.sheen.rgb * shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase += info.diffuse * shadowDebug{X};\n            #else\n                diffuseBase += info.diffuse * shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase += info.specular * shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase += info.clearCoat.rgb * shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase += info.sheen.rgb * shadow;\n            #endif\n        #endif\n    #endif\n#endif\n",c.Effect.IncludesShadersStore.mtoonBumpFragment="// replace vBumpUV to mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        // vec2 TBNUV = gl_FrontFacing ? vBumpUV : -vBumpUV;\n        vec2 TBNUV = gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vTangentSpaceParams);\n    #else\n        vec2 TBNUV = gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        // flip the uv for the backface\n        vec2 TBNUV = gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN = cotangent_frame(normalW, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        // uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, vBumpUV, vBumpInfos.z);\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        // normalW = normalize(texture2D(bumpSampler, vBumpUV).xyz  * 2.0 - 1.0);\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        // normalW = perturbNormal(TBN, texture2D(bumpSampler, vBumpUV + uvOffset).xyz, vBumpInfos.y);\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        // vec3 bumpNormal = texture2D(bumpSampler, vBumpUV + uvOffset).xyz * 2.0 - 1.0;\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n",c.Effect.ShadersStore.mtoonVertexShader="// it is based on default.vertex.fx\n// This include is special, it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n// Attributes\n\n#define CUSTOM_VERTEX_BEGIN\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n// # if defined(SPECULARTERM)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n// # endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\n// Additional Uniforms\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # endif\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n\n    #define CUSTOM_VERTEX_MAIN_BEGIN\n\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated = uv;\n#endif\n\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n//     vPositionUVW = positionUpdated;\n// # endif\n\n#define CUSTOM_VERTEX_UPDATE_POSITION\n\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n\n#include<instancesVertex>\n\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n    // Compute velocity before bones computation\n    vCurrentPosition = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\n    vPreviousPosition = previousViewProjection * finalPreviousWorld * vec4(positionUpdated, 1.0);\n#endif\n\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n\n    // Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated = vec2(0., 0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1 = uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n\n    float outlineTex = 1.0;\n    if (isOutline == 1.0) {\n#ifdef OUTLINE_WIDTH\n    #if OUTLINE_WIDTHDIRECTUV == 0\n        if (vOutlineWidthInfos.x == 0.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uvUpdated, 1.0, 0.0));\n        }\n        #ifdef UV2\n        else if (vOutlineWidthInfos.x == 1.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV3\n        else if (vOutlineWidthInfos.x == 2.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv3, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV4\n        else if (vOutlineWidthInfos.x == 3.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv4, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV5\n        else if (vOutlineWidthInfos.x == 4.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv5, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV6\n        else if (vOutlineWidthInfos.x == 5.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv6, 1.0, 0.0));\n        }\n        #endif\n    #elif defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n        outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n        // move slightly world normal\n        vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * length(transposeMat3(inverseMat3(mat3(finalWorld))) * normalUpdated) * normalUpdated;\n        positionUpdated += outlineOffset;\n#endif\n    } // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW = normalUpdated / vec3(dot(normalWorld[0], normalWorld[0]), dot(normalWorld[1], normalWorld[1]), dot(normalWorld[2], normalWorld[2]));\n        vNormalW = normalize(normalWorld * vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n\n        vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    if (isOutline == 1.0) {\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n        vec3 viewNormal = transposeMat3(inverseMat3(mat3(view) * mat3(finalWorld))) * normalUpdated;\n        vec3 clipNormal = mat3(projection) * viewNormal;\n        vec2 projectedNormal = normalize(clipNormal.xy);\n        projectedNormal *= min(gl_Position.w, outlineScaledMaxDistance);\n        projectedNormal.x /= aspect; // aspect in original mtoon is y/x. aspect in babylon is x/y.\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(normalize(viewNormal).z), 0.0, 1.0); // ignore offset when normal toward camera\n#endif\n\n        gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n    worldPos = finalWorld * vec4(positionUpdated, 1.0);\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n//     vDirectionW = normalize(vec3(finalWorld * vec4(positionUpdated, 0.0)));\n// # endif\n\n    #include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n    // # if defined(SPECULARTERM)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n    // # endif\n    #include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,uvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\n    vColor = color;\n#elif defined(INSTANCESCOLOR) && INSTANCESCOLOR\n    vColor = instanceColor;\n#endif\n\n#include<pointCloudVertex>\n#include<logDepthVertex>\n\n#define CUSTOM_VERTEX_MAIN_END\n\n}\n",c.Effect.ShadersStore.mtoonFragmentShader="#include<__decl__mtoonFragment>\n\n#extension GL_OES_standard_derivatives : enable\n\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n\n#define CUSTOM_FRAGMENT_BEGIN\n\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n// #define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n#include<mtoonFragmentFunctions>\n\n// # ifdef REFRACTION\n\n// # ifdef REFRACTIONMAP_3D\n// uniform samplerCube refractionCubeSampler;\n// # else\n// uniform sampler2D refraction2DSampler;\n// # endif\n\n// # endif\n\n// # if defined(SPECULARTERM)\n//     # include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n// # endif\n\n// // Fresnel\n// # include<fresnelFunction>\n\n// // Reflection\n// # ifdef REFLECTION\n// # ifdef REFLECTIONMAP_3D\n// uniform samplerCube reflectionCubeSampler;\n// # else\n// uniform sampler2D reflection2DSampler;\n// # endif\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # else\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n// # endif\n\n// # include<reflectionFunction>\n\n// # endif\n\n#include<imageProcessingDeclaration>\n\n#include<imageProcessingFunctions>\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\n\nvoid main(void) {\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\n    #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n    #else\n        discard;\n    #endif\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n\n#include<oitFragment>\n\n#include<clipPlaneFragment>\n\n    vec3 viewDirectionW = normalize(vEyePosition.xyz - vPositionW);\n\n    // Base color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n\n    // Alpha\n    float alpha = 1.0;\n\n    // Bump\n#ifdef NORMAL\n    vec3 normalW = normalize(vNormalW);\n#else\n    vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n#include<depthPrePass>\n\n    // Ambient color\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\n    float glossiness = 0.;\n\n    // Lighting\n    vec3 diffuseBase = vec3(0., 0., 0.);\n    lightingInfo info;\n    float shadow = 1.;\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // MToon UV\n    // All textures will use diffuse(_MainTex) UV\n    vec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#endif\n\n    // uv anim\n    float uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\n    uvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n    // translate uv in bottom-left origin coordinates.\n    // uv is reversed\n    mainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\n    float rotateRad = uvAnimationRotation * PI_2 * uvAnim;\n    vec2 rotatePivot = vec2(0.5, 0.5);\n    mainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#ifdef FLIP_U\n    mainUv.x = 1.0 - mainUv.x;\n#endif\n#ifdef FLIP_V\n    mainUv.y = 1.0 - mainUv.y;\n#endif\n\n#include<mtoonBumpFragment>\n\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n// include customized lightFragment\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n    vec3 finalDiffuse = clamp(diffuseBase, 0.0, 1.0) * baseColor.rgb;\n\n    // Composition\n    vec4 color = vec4(finalDiffuse, clamp(alpha, 0.0, 1.0));\n\n    color.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n// Apply image processing if relevant. As this applies in linear space,\n// We first move from gamma to linear.\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n    color.rgb = toLinearSpace(color.rgb);\n#else\n    #ifdef IMAGEPROCESSING\n        // FIXME: support image processing\n        // color.rgb = toLinearSpace(color.rgb);\n        // color = applyImageProcessing(color);\n    #endif\n#endif\n\n    color.a *= visibility;\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#ifdef PREPASS\n    float writeGeometryInfo = color.a > 0.4 ? 1.0 : 0.0;\n\n    gl_FragData[0] = color; // We can't split irradiance on std material\n\n    #ifdef PREPASS_POSITION\n    gl_FragData[PREPASS_POSITION_INDEX] = vec4(vPositionW, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_VELOCITY\n    vec2 a = (vCurrentPosition.xy / vCurrentPosition.w) * 0.5 + 0.5;\n    vec2 b = (vPreviousPosition.xy / vPreviousPosition.w) * 0.5 + 0.5;\n\n    vec2 velocity = abs(a - b);\n    velocity = vec2(pow(velocity.x, 1.0 / 3.0), pow(velocity.y, 1.0 / 3.0)) * sign(a - b) * 0.5 + 0.5;\n\n    gl_FragData[PREPASS_VELOCITY_INDEX] = vec4(velocity, 0.0, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_IRRADIANCE\n        gl_FragData[PREPASS_IRRADIANCE_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); //  We can't split irradiance on std material\n    #endif\n\n    #ifdef PREPASS_DEPTH\n        gl_FragData[PREPASS_DEPTH_INDEX] = vec4(vViewPos.z, 0.0, 0.0, writeGeometryInfo); // Linear depth\n    #endif\n\n    #ifdef PREPASS_NORMAL\n        gl_FragData[PREPASS_NORMAL_INDEX] = vec4((view * vec4(normalW, 0.0)).rgb, writeGeometryInfo); // Normal\n    #endif\n\n    #ifdef PREPASS_ALBEDO_SQRT\n        gl_FragData[PREPASS_ALBEDO_SQRT_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); // We can't split albedo on std material\n    #endif\n    #ifdef PREPASS_REFLECTIVITY\n        #if defined(SPECULAR)\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(specularMapColor.rgb, specularMapColor.a * writeGeometryInfo);\n        #else\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo);\n        #endif\n    #endif\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor = color;\n#endif\n\n#if ORDER_INDEPENDENT_TRANSPARENCY\n    if (fragDepth == nearestDepth) {\n        frontColor.rgb += color.rgb * color.a * alphaMultiplier;\n        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);\n    } else {\n        backColor += color;\n    }\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_END\n\n}\n"),this.inspectableCustomProperties=this.inspectableCustomProperties||[],this.inspectableCustomProperties.push({label:"DiffuseColor",propertyName:"diffuseColor",type:_.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:_.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:_.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:_.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:_.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:_.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:_.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:_.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:_.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:_.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:_.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:_.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:_.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:_.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:_.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:_.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:_.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:_.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:_.InspectableType.Slider,min:-.5,max:.5,step:.01})}get appendedTextures(){return[this._diffuseTexture,this._emissiveTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture]}get appendedActiveTextures(){return this.appendedTextures.filter((e=>null!==e))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsTexturesDirty()}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingConfiguration=e||this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add((()=>{this._markAllSubMeshesAsImageProcessingDirty()}))))}get isPrePassCapable(){return!1}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(e){this._imageProcessingConfiguration.exposure=e}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(e){this._imageProcessingConfiguration.contrast=e}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(e){this._imageProcessingConfiguration.colorGradingTexture=e}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(e){this._imageProcessingConfiguration.colorCurves=e}get canRenderToMRT(){return!0}get bumpScale(){return this._bumpScale}set bumpScale(e){this._bumpScale=e}get receiveShadowRate(){return this._receiveShadowRate}set receiveShadowRate(e){this._receiveShadowRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadingGradeRate(){return this._shadingGradeRate}set shadingGradeRate(e){this._shadingGradeRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeShift(){return this._shadeShift}set shadeShift(e){this._shadeShift=Math.max(-1,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeToony(){return this._shadeToony}set shadeToony(e){this._shadeToony=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get lightColorAttenuation(){return this._lightColorAttenuation}set lightColorAttenuation(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get indirectLightIntensity(){return this._indirectLightIntensity}set indirectLightIntensity(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimLightingMix(){return this._rimLightingMix}set rimLightingMix(e){this._rimLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimFresnelPower(){return this._rimFresnelPower}set rimFresnelPower(e){this._rimFresnelPower=Math.max(0,Math.min(100,e)),this._markAllSubMeshesAsLightsDirty()}get rimLift(){return this._rimLift}set rimLift(e){this._rimLift=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get outlineWidth(){return this._outlineWidth}set outlineWidth(e){this._outlineWidth=Math.max(.01,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineScaledMaxDistance(){return this._outlineScaledMaxDistance}set outlineScaledMaxDistance(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineLightingMix(){return this._outlineLightingMix}set outlineLightingMix(e){this._outlineLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get uvAnimationScrollX(){return this._uvAnimationScrollX}set uvAnimationScrollX(e){this._uvAnimationScrollX=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationScrollY(){return this._uvAnimationScrollY}set uvAnimationScrollY(e){this._uvAnimationScrollY=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationRotation(){return this._uvAnimationRotation}set uvAnimationRotation(e){this._uvAnimationRotation=e,this._markAllSubMeshesAsMiscDirty()}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest=e,e?this.alphaBlend?this._transparencyMode=d.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=d.Material.MATERIAL_ALPHATEST:this.alphaBlend?this._transparencyMode=d.Material.MATERIAL_ALPHABLEND:this._transparencyMode=d.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get alphaBlend(){return this._alphaBlend}set alphaBlend(e){this._alphaBlend=e,e?(this.backFaceCulling=!0,this.alphaTest?this._transparencyMode=d.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=d.Material.MATERIAL_ALPHABLEND):this.alphaTest?this._transparencyMode=d.Material.MATERIAL_ALPHATEST:this._transparencyMode=d.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,e===D.None||this.outlineRenderer||(this.outlineRenderer=new A(this.getScene(),this)),this._markAllSubMeshesAsMiscDirty()}enableOutlineRender(){this.isOutline=1}disaableOutlineRender(){this.isOutline=0}get cullMode(){return this._cullMode}set cullMode(e){switch(this._cullMode=e,this._cullMode){case C.Off:this.backFaceCulling=!1,this.sideOrientation=d.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case C.Front:this.backFaceCulling=!0,this.sideOrientation=d.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case C.Back:this.backFaceCulling=!0,this.sideOrientation=d.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this._markAllSubMeshesAsMiscDirty()}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}get hasRenderTargetTextures(){return!1}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){const t=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==t&&(this._useLogarithmicDepth=t,this._markAllSubMeshesAsMiscDirty())}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}_shouldUseAlphaFromDiffuseTexture(){return null!=this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==d.Material.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,t,i=!1){this._uniformBufferLayoutBuilt||this.buildUniformLayout();const n=t._drawWrapper;if(n.effect&&this.isFrozen&&n._wasPreviouslyReady&&n._wasPreviouslyUsingInstances===i)return!0;t.materialDefines||(this._callbackPluginEventGeneric(g.MaterialPluginEvent.GetDefineNames,this._eventInfo),t.materialDefines=new S);const r=this.getScene(),a=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const o=r.getEngine();a._needNormals=f.MaterialHelper.PrepareDefinesForLights(r,e,a,this.specularSupported,this._maxSimultaneousLights,this._disableLighting),this.outlineWidthMode!==D.None&&(a._needNormals=!0),this.applyDefines(a),f.MaterialHelper.PrepareDefinesForMultiview(r,a);const d=this.needAlphaBlendingForMesh(e)&&r.useOrderIndependentTransparency;if(f.MaterialHelper.PrepareDefinesForOIT(r,a,d),a._areTexturesDirty){this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,a._needUVs=!1;for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)a["MAINUV"+e]=!1;if(r.texturesEnabled){if(!(this.isReadyForTexture(this._diffuseTexture,a,"DIFFUSE")&&this.isReadyForTexture(this._emissiveTexture,a,"EMISSIVE")&&this.isReadyForTexture(this._shadeTexture,a,"SHADE")&&this.isReadyForTexture(this._receiveShadowTexture,a,"RECEIVE_SHADOW")&&this.isReadyForTexture(this._shadingGradeTexture,a,"SHADING_GRADE")&&this.isReadyForTexture(this._rimTexture,a,"RIM")&&this.isReadyForTexture(this._matCapTexture,a,"MATCAP")&&this.isReadyForTexture(this._outlineWidthTexture,a,"OUTLINE_WIDTH")&&this.isReadyForTexture(this._uvAnimationMaskTexture,a,"UV_ANIMATION_MASK")))return!1;if(r.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;f.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,a,"BUMP"),a.PARALLAX=this.useParallax,a.PARALLAXOCCLUSION=this.useParallaxOcclusion,a.OBJECTSPACE_NORMALMAP=this.useObjectSpaceNormalMap}else a.BUMP=!1,a.PARALLAX=!1,a.PARALLAXOCCLUSION=!1;a.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else a.DIFFUSE=!1,a.EMISSIVE=!1,a.SHADE=!1,a.RECEIVE_SHADOW=!1,a.SHADING_GRADE=!1,a.RIM=!1,a.MATCAP=!1,a.OUTLINE_WIDTH=!1,a.BUMP=!1,a.UV_ANIMATION_MASK=!1;a.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),a.PREMULTIPLYALPHA=this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF,a.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,a.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(e)}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=a,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(a._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(a)}this.flipU!==a.FLIP_U&&(a.FLIP_U=this.flipU,a.markAsUnprocessed()),this.flipV!==a.FLIP_V&&(a.FLIP_V=this.flipV,a.markAsUnprocessed()),f.MaterialHelper.PrepareDefinesForMisc(e,r,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this.needAlphaTestingForMesh(e),a);const h=t.getMaterial();if(h){let e=o;f.MaterialHelper.PrepareDefinesForFrameBoundValues(r,e,h,a,i,null,t.getRenderingMesh().hasThinInstances)}if(this._eventInfo.defines=a,this._eventInfo.mesh=e,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),f.MaterialHelper.PrepareDefinesForAttributes(e,a,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha,this.useBakedVertexAnimation),this._callbackPluginEventPrepareDefines(this._eventInfo),a.isDirty){const i=a._areLightsDisposed;a.markAsProcessed();const n=new m.EffectFallbacks;a.BUMP&&n.addFallback(0,"BUMP"),a.PARALLAX&&n.addFallback(1,"PARALLAX"),a.PARALLAXOCCLUSION&&n.addFallback(0,"PARALLAXOCCLUSION"),a.FOG&&n.addFallback(1,"FOG"),a.POINTSIZE&&n.addFallback(0,"POINTSIZE"),a.LOGARITHMICDEPTH&&n.addFallback(0,"LOGARITHMICDEPTH"),f.MaterialHelper.HandleFallbacksForShadows(a,n,this._maxSimultaneousLights),a.MULTIVIEW&&n.addFallback(0,"MULTIVIEW");const d=[s.VertexBuffer.PositionKind];a.NORMAL&&d.push(s.VertexBuffer.NormalKind),a.TANGENT&&d.push(s.VertexBuffer.TangentKind);for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)a["UV"+e]&&d.push(`uv${1===e?"":e}`);a.INSTANCESCOLOR&&d.push(s.VertexBuffer.ColorInstanceKind),f.MaterialHelper.PrepareAttributesForBones(d,e,a,n),f.MaterialHelper.PrepareAttributesForInstances(d,a),f.MaterialHelper.PrepareAttributesForMorphTargets(d,e,a),f.MaterialHelper.PrepareAttributesForBakedVertexAnimation(d,e,a);const h="mtoon",c=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","visibility","vFogInfos","vFogColor","pointSize","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","morphTargetTextureInfo","morphTargetTextureIndices","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","projection"],p=["diffuseSampler","ambientSampler","emissiveSampler","bumpSampler","boneSampler","morphTargets","oitDepthSampler","oitFrontColorSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler"],_=["Material","Scene","Mesh"];this._eventInfo.fallbacks=n,this._eventInfo.fallbackRank=0,this._eventInfo.defines=a,this._eventInfo.uniforms=c,this._eventInfo.attributes=d,this._eventInfo.samplers=p,this._eventInfo.uniformBuffersNames=_,this._eventInfo.customCode=void 0,this._eventInfo.mesh=e,this._callbackPluginEventGeneric(g.MaterialPluginEvent.PrepareEffect,this._eventInfo),l.ImageProcessingConfiguration&&(l.ImageProcessingConfiguration.PrepareUniforms(c,a),l.ImageProcessingConfiguration.PrepareSamplers(p,a)),f.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:c,uniformBuffersNames:_,samplers:p,defines:a,maxSimultaneousLights:this._maxSimultaneousLights});const M={},A=a.toString(),v=t.effect;let I=r.getEngine().createEffect(h,{attributes:d,uniformsNames:c,uniformBuffersNames:_,samplers:p,defines:A,fallbacks:n,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:a.NUM_MORPH_INFLUENCERS},processFinalCode:M.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:a.PREPASS},o);if(I)if(this._onEffectCreatedObservable&&(E.effect=I,E.subMesh=t,this._onEffectCreatedObservable.notifyObservers(E)),this.allowShaderHotSwapping&&v&&!I.isReady()){if(I=v,a.markAsUnprocessed(),i)return a._areLightsDisposed=!0,!1}else r.resetCachedMaterial(),t.setEffect(I,a,this._materialContext)}return!(!t.effect||!t.effect.isReady()||(a._renderId=r.getRenderId(),n._wasPreviouslyReady=!0,n._wasPreviouslyUsingInstances=i,0))}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("vDiffuseColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("diffuseMatrix",16),e.addUniform("vEmissiveColor",3),e.addUniform("vEmissiveInfos",2),e.addUniform("emissiveMatrix",16),e.addUniform("vBumpInfos",3),e.addUniform("bumpMatrix",16),e.addUniform("vShadeColor",3),e.addUniform("vShadeInfos",2),e.addUniform("shadeMatrix",16),e.addUniform("vReceiveShadowInfos",2),e.addUniform("receiveShadowMatrix",16),e.addUniform("vShadingGradeInfos",2),e.addUniform("shadingGradeMatrix",16),e.addUniform("vRimColor",3),e.addUniform("vRimInfos",2),e.addUniform("rimMatrix",16),e.addUniform("vMatCapInfos",2),e.addUniform("matCapMatrix",16),e.addUniform("vOutlineColor",3),e.addUniform("vOutlineWidthInfos",2),e.addUniform("outlineWidthMatrix",16),e.addUniform("vUvAnimationMaskInfos",2),e.addUniform("uvAnimationMaskMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("shadingGradeRate",1),e.addUniform("receiveShadowRate",1),e.addUniform("shadeShift",1),e.addUniform("shadeToony",1),e.addUniform("lightColorAttenuation",1),e.addUniform("indirectLightIntensity",1),e.addUniform("rimLightingMix",1),e.addUniform("rimFresnelPower",1),e.addUniform("rimLift",1),e.addUniform("outlineWidth",1),e.addUniform("outlineScaledMaxDistance",1),e.addUniform("outlineLightingMix",1),e.addUniform("uvAnimationScrollX",1),e.addUniform("uvAnimationScrollY",1),e.addUniform("uvAnimationRotation",1),e.addUniform("vEyeUp",3),e.addUniform("alphaCutOff",1),e.addUniform("vAmbientColor",3),e.addUniform("aspect",1),e.addUniform("isOutline",1),e.addUniform("time",4),e.addUniform("visibility",1),super.buildUniformLayout()}bindForSubMesh(e,t,i){var n;const o=this.getScene(),s=i.materialDefines,l=i.effect;if(!s||!l)return;this._activeEffect=l,t.getMeshUniformBuffer().bindToEffect(l,"Mesh"),t.transferToEffect(e),this._uniformBuffer.bindToEffect(l,"Material"),this._eventInfo.subMesh=i,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),s.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const d=this._mustRebind(o,l,i,t.visibility);f.MaterialHelper.BindBonesParameters(t,l);const h=this._uniformBuffer;if(d){this.bindViewProjection(l),h.useUbo&&this.isFrozen&&h.isSync||(o.texturesEnabled&&(this.bindTexture(this._diffuseTexture,h,l,"diffuse","vDiffuseInfos"),this.bindTexture(this._emissiveTexture,h,l,"emissive","vEmissiveInfos"),this._bumpTexture&&o.getEngine().getCaps().standardDerivatives&&(h.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this._bumpScale),f.MaterialHelper.BindTextureMatrix(this._bumpTexture,h,"bump"),l.setTexture("bumpSampler",this._bumpTexture),o._mirroredCameraPosition?h.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):h.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1)),this.bindTexture(this._shadeTexture,h,l,"shade","vShadeInfos"),this.bindTexture(this._receiveShadowTexture,h,l,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this._shadingGradeTexture,h,l,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this._rimTexture,h,l,"rim","vRimInfos"),this.bindTexture(this._matCapTexture,h,l,"matCap","vMatCapInfos"),this.bindTexture(this._outlineWidthTexture,h,l,"outlineWidth","vOutlineWidthInfos"),this.bindTexture(this._uvAnimationMaskTexture,h,l,"uvAnimationMask","vUvAnimationMaskInfos"),this._hasAlphaChannel()&&h.updateFloat("alphaCutOff",this.alphaCutOff)),this.pointsCloud&&h.updateFloat("pointSize",this.pointSize),h.updateFloat("receiveShadowRate",this._receiveShadowRate),h.updateFloat("shadingGradeRate",this._shadingGradeRate),h.updateFloat("shadeShift",this._shadeShift),h.updateFloat("shadeToony",this._shadeToony),h.updateFloat("lightColorAttenuation",this._lightColorAttenuation),h.updateFloat("indirectLightIntensity",this._indirectLightIntensity),h.updateFloat("rimLightingMix",this._rimLightingMix),h.updateFloat("rimFresnelPower",this._rimFresnelPower),h.updateFloat("rimLift",this._rimLift),h.updateFloat("outlineWidth",this._outlineWidth),h.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),h.updateFloat("outlineLightingMix",this._outlineLightingMix),h.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),h.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),h.updateFloat("uvAnimationRotation",this._uvAnimationRotation),o.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),h.updateColor3("vAmbientColor",this._globalAmbientColor),h.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),h.updateColor3("vEmissiveColor",this.emissiveColor),h.updateColor3("vShadeColor",this.shadeColor),h.updateColor3("vRimColor",this.rimColor),h.updateColor4("vOutlineColor",this.outlineColor,1),h.updateVector3("vEyeUp",o.activeCamera.upVector));const e=o;e.useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(t)&&e.depthPeelingRenderer&&e.depthPeelingRenderer.bind(l),this._eventInfo.subMesh=i,this._callbackPluginEventBindForSubMesh(this._eventInfo),class{static BindClipPlane(e,t){if(t.clipPlane){const i=t.clipPlane;e.setFloat4("vClipPlane",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane2){const i=t.clipPlane2;e.setFloat4("vClipPlane2",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane3){const i=t.clipPlane3;e.setFloat4("vClipPlane3",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane4){const i=t.clipPlane4;e.setFloat4("vClipPlane4",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane5){const i=t.clipPlane5;e.setFloat4("vClipPlane5",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane6){const i=t.clipPlane6;e.setFloat4("vClipPlane6",i.normal.x,i.normal.y,i.normal.z,i.d)}}}.BindClipPlane(l,o),o.clipPlane=null,this.bindEyePosition(l)}else o.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);if(d||!this.isFrozen){o.lightsEnabled&&!this._disableLighting&&f.MaterialHelper.BindLights(o,t,l,s,this._maxSimultaneousLights),(o.fogEnabled&&t.applyFog&&o.fogMode!==r.Scene.FOGMODE_NONE||t.receiveShadows)&&this.bindView(l),f.MaterialHelper.BindFogParameters(o,t,l),s.NUM_MORPH_INFLUENCERS&&f.MaterialHelper.BindMorphTargetParameters(t,l),s.BAKED_VERTEX_ANIMATION_TEXTURE&&(null===(n=t.bakedVertexAnimationManager)||void 0===n||n.bind(l,s.INSTANCES)),this.useLogarithmicDepth&&f.MaterialHelper.BindLogDepth(s,l,o),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(this._activeEffect),h.updateFloat("aspect",o.getEngine().getAspectRatio(o.activeCamera)),h.updateFloat("isOutline",this.isOutline);const e=window.performance.now()/1e3;h.updateVector4("time",new a.Vector4(e/20,e,2*e,3*e))}this._afterBind(t,this._activeEffect),h.update()}getAnimatables(){const e=super.getAnimatables();for(const t of this.appendedActiveTextures)t.animations&&t.animations.length>0&&e.push(t);return e}getActiveTextures(){return super.getActiveTextures().concat(this.appendedActiveTextures)}hasTexture(e){if(super.hasTexture(e))return!0;for(const t of this.appendedActiveTextures)if(t===e)return!0;return!1}dispose(e,t){if(delete this.outlineRenderer,t)for(const e of this.appendedActiveTextures)e.dispose();this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(e,t)}clone(e){const t=i.SerializationHelper.Clone((()=>new P(e,this.getScene())),this);return t.name=e,t.id=e,this.stencil.copyTo(t.stencil),t}static Parse(e,t,n){const r=i.SerializationHelper.Parse((()=>new P(e.name,t)),e,t,n);return e.stencil&&r.stencil.parse(e.stencil,t,n),r}bindTexture(e,t,i,n,r){e&&(this._uniformBuffer.updateFloat2(r,e.coordinatesIndex,e.level),f.MaterialHelper.BindTextureMatrix(e,t,n),i.setTexture(`${n}Sampler`,e))}isReadyForTexture(e,t,i){return e?!!e.isReadyOrNotBlocking()&&(f.MaterialHelper.PrepareDefinesForMergedUV(e,t,i),!0):(t[i]=!1,!0)}applyDefines(e){switch(this._debugMode){case x.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case x.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case x.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case D.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case D.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case D.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case N.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case N.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}}e([(0,t.serializeAsTexture)("diffuseTexture")],P.prototype,"_diffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],P.prototype,"diffuseTexture",void 0),e([(0,t.serializeAsTexture)("emissiveTexture")],P.prototype,"_emissiveTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"emissiveTexture",void 0),e([(0,t.serializeAsTexture)("bumpTexture")],P.prototype,"_bumpTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"bumpTexture",void 0),e([(0,t.serializeAsTexture)("shadeTexture")],P.prototype,"_shadeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"shadeTexture",void 0),e([(0,t.serializeAsTexture)("receiveShadowTexture")],P.prototype,"_receiveShadowTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"receiveShadowTexture",void 0),e([(0,t.serializeAsTexture)("shadingGradeTexture")],P.prototype,"_shadingGradeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"shadingGradeTexture",void 0),e([(0,t.serializeAsTexture)("rimTexture")],P.prototype,"_rimTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"rimTexture",void 0),e([(0,t.serializeAsTexture)("matCapTexture")],P.prototype,"_matCapTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"matCapTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],P.prototype,"_outlineWidthTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"outlineWidthTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],P.prototype,"_uvAnimationMaskTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"uvAnimationMaskTexture",void 0),e([(0,t.serializeAsColor3)("diffuse")],P.prototype,"diffuseColor",void 0),e([(0,t.serialize)("ambient")],P.prototype,"ambientColor",void 0),e([(0,t.serialize)("emissive")],P.prototype,"emissiveColor",void 0),e([(0,t.serialize)("shade")],P.prototype,"shadeColor",void 0),e([(0,t.serialize)("rim")],P.prototype,"rimColor",void 0),e([(0,t.serialize)("outline")],P.prototype,"outlineColor",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"useEmissiveAsIllumination",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"linkEmissiveWithDiffuse",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"useReflectionOverAlpha",void 0),e([(0,t.serialize)("disableLighting")],P.prototype,"_disableLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],P.prototype,"disableLighting",void 0),e([(0,t.serialize)()],P.prototype,"alphaCutOff",void 0),e([(0,t.serialize)("useAlphaFromDiffuseTexture")],P.prototype,"_useAlphaFromDiffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],P.prototype,"useAlphaFromDiffuseTexture",void 0),e([(0,t.serialize)("maxSimultaneousLights")],P.prototype,"_maxSimultaneousLights",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],P.prototype,"maxSimultaneousLights",void 0),e([(0,t.serialize)("invertNormalMapX")],P.prototype,"_invertNormalMapX",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"invertNormalMapX",void 0),e([(0,t.serialize)("invertNormalMapY")],P.prototype,"_invertNormalMapY",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"invertNormalMapY",void 0),e([(0,t.serialize)("twoSidedLighting")],P.prototype,"_twoSidedLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],P.prototype,"twoSidedLighting",void 0),e([(0,t.serialize)()],P.prototype,"bumpScale",null),e([(0,t.serialize)()],P.prototype,"receiveShadowRate",null),e([(0,t.serialize)()],P.prototype,"shadingGradeRate",null),e([(0,t.serialize)()],P.prototype,"shadeShift",null),e([(0,t.serialize)()],P.prototype,"shadeToony",null),e([(0,t.serialize)()],P.prototype,"lightColorAttenuation",null),e([(0,t.serialize)()],P.prototype,"indirectLightIntensity",null),e([(0,t.serialize)()],P.prototype,"rimLightingMix",null),e([(0,t.serialize)()],P.prototype,"rimFresnelPower",null),e([(0,t.serialize)()],P.prototype,"rimLift",null),e([(0,t.serialize)()],P.prototype,"outlineWidth",null),e([(0,t.serialize)()],P.prototype,"outlineScaledMaxDistance",null),e([(0,t.serialize)()],P.prototype,"outlineLightingMix",null),e([(0,t.serialize)()],P.prototype,"uvAnimationScrollX",null),e([(0,t.serialize)()],P.prototype,"uvAnimationScrollY",null),e([(0,t.serialize)()],P.prototype,"uvAnimationRotation",null),e([(0,t.serialize)("alphaTest")],P.prototype,"_alphaTest",void 0),e([(0,t.serialize)()],P.prototype,"alphaTest",null),e([(0,t.serialize)()],P.prototype,"alphaBlend",null),e([(0,t.serialize)("debugMode")],P.prototype,"_debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],P.prototype,"debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],P.prototype,"outlineColorMode",void 0),e([(0,t.serialize)()],P.prototype,"cullMode",null),e([(0,t.serialize)()],P.prototype,"_outlineCullMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],P.prototype,"outlineCullMode",void 0),e([(0,t.serialize)("flipU")],P.prototype,"flipU",void 0),e([(0,t.serialize)("flipV")],P.prototype,"flipV",void 0),e([(0,t.serialize)()],P.prototype,"useLogarithmicDepth",null)})(),T})(),e.exports=n(i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5))},5:e=>{"use strict";e.exports=BABYLON}},t={};function i(n){var r=t[n];if(void 0!==r)return r.exports;var a=t[n]={exports:{}};return e[n](a,a.exports,i),a.exports}i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{"use strict";i.r(n),i.d(n,{BoneNotFoundError:()=>e,HumanoidBone:()=>t,IVRMMaterialPropertyShader:()=>u,MaterialValueBindingMerger:()=>h,VCAST_vci_material_unity:()=>g,VRM:()=>L,VRMFileLoader:()=>R,VRMFileLoaderPlugin:()=>y,VRMManager:()=>P,VRMMaterialGenerator:()=>m});class e extends Error{constructor(e){super(`Bone:${e} NotFound`),this.boneName=e,this.name="BoneNotFoundError"}}class t{constructor(e){this.nodeMap=e}dispose(){this.nodeMap=null}get hips(){return this.getMandatoryBone("hips")}get leftUpperLeg(){return this.getMandatoryBone("leftUpperLeg")}get rightUpperLeg(){return this.getMandatoryBone("rightUpperLeg")}get leftLowerLeg(){return this.getMandatoryBone("leftLowerLeg")}get rightLowerLeg(){return this.getMandatoryBone("rightLowerLeg")}get leftFoot(){return this.getMandatoryBone("leftFoot")}get rightFoot(){return this.getMandatoryBone("rightFoot")}get spine(){return this.getMandatoryBone("spine")}get chest(){return this.getMandatoryBone("chest")}get neck(){return this.getMandatoryBone("neck")}get head(){return this.getMandatoryBone("head")}get leftShoulder(){return this.getMandatoryBone("leftShoulder")}get rightShoulder(){return this.getMandatoryBone("rightShoulder")}get leftUpperArm(){return this.getMandatoryBone("leftUpperArm")}get rightUpperArm(){return this.getMandatoryBone("rightUpperArm")}get leftLowerArm(){return this.getMandatoryBone("leftLowerArm")}get rightLowerArm(){return this.getMandatoryBone("rightLowerArm")}get leftHand(){return this.getMandatoryBone("leftHand")}get rightHand(){return this.getMandatoryBone("rightHand")}get leftToes(){return this.getOptionalBone("leftToes")}get rightToes(){return this.getOptionalBone("rightToes")}get leftEye(){return this.getOptionalBone("leftEye")}get rightEye(){return this.getOptionalBone("rightEye")}get jaw(){return this.getOptionalBone("jaw")}get leftThumbProximal(){return this.getOptionalBone("leftThumbProximal")}get leftThumbIntermediate(){return this.getOptionalBone("leftThumbIntermediate")}get leftThumbDistal(){return this.getOptionalBone("leftThumbDistal")}get leftIndexProximal(){return this.getOptionalBone("leftIndexProximal")}get leftIndexIntermediate(){return this.getOptionalBone("leftIndexIntermediate")}get leftIndexDistal(){return this.getOptionalBone("leftIndexDistal")}get leftMiddleProximal(){return this.getOptionalBone("leftMiddleProximal")}get leftMiddleIntermediate(){return this.getOptionalBone("leftMiddleIntermediate")}get leftMiddleDistal(){return this.getOptionalBone("leftMiddleDistal")}get leftRingProximal(){return this.getOptionalBone("leftRingProximal")}get leftRingIntermediate(){return this.getOptionalBone("leftRingIntermediate")}get leftRingDistal(){return this.getOptionalBone("leftRingDistal")}get leftLittleProximal(){return this.getOptionalBone("leftLittleProximal")}get leftLittleIntermediate(){return this.getOptionalBone("leftLittleIntermediate")}get leftLittleDistal(){return this.getOptionalBone("leftLittleDistal")}get rightThumbProximal(){return this.getOptionalBone("rightThumbProximal")}get rightThumbIntermediate(){return this.getOptionalBone("rightThumbIntermediate")}get rightThumbDistal(){return this.getOptionalBone("rightThumbDistal")}get rightIndexProximal(){return this.getOptionalBone("rightIndexProximal")}get rightIndexIntermediate(){return this.getOptionalBone("rightIndexIntermediate")}get rightIndexDistal(){return this.getOptionalBone("rightIndexDistal")}get rightMiddleProximal(){return this.getOptionalBone("rightMiddleProximal")}get rightMiddleIntermediate(){return this.getOptionalBone("rightMiddleIntermediate")}get rightMiddleDistal(){return this.getOptionalBone("rightMiddleDistal")}get rightRingProximal(){return this.getOptionalBone("rightRingProximal")}get rightRingIntermediate(){return this.getOptionalBone("rightRingIntermediate")}get rightRingDistal(){return this.getOptionalBone("rightRingDistal")}get rightLittleProximal(){return this.getOptionalBone("rightLittleProximal")}get rightLittleIntermediate(){return this.getOptionalBone("rightLittleIntermediate")}get rightLittleDistal(){return this.getOptionalBone("rightLittleDistal")}get upperChest(){return this.getOptionalBone("upperChest")}getMandatoryBone(t){const i=this.nodeMap[t];if(!i)throw new e(t);return i}getOptionalBone(e){return this.nodeMap&&this.nodeMap[e]||null}}var r=i(5),a=i(731);const o={_MainTex:"albedoTexture"},s={_Color:"albedoColor"},l={_MainTex:"diffuseTexture",_EmissionMap:"emissiveTexture",_BumpMap:"bumpTexture",_ShadeTexture:"shadeTexture",_ReceiveShadowTexture:"receiveShadowTexture",_ShadingGradeTexture:"shadingGradeTexture",_RimTexture:"rimTexture",_SphereAdd:"matCapTexture",_OutlineWidthTexture:"outlineWidthTexture",_UvAnimMaskTexture:"uvAnimationMaskTexture"},d={_Color:"diffuseColor",_ShadeColor:"shadeColor",_RimColor:"rimColor",_EmissionColor:"emissiveColor",_OutlineColor:"outlineColor"};class h{constructor(e,t){this.materialValues=t,this.m_materialMap={},this.m_materialSetterMap={},this.m_materialValueMap={},this.m_used={},this.baseValueCache={},this.materialValuesToApply={},0!==e.length&&0!==t.length&&(e.forEach((e=>{(e instanceof a.MToonMaterial||e instanceof r.PBRMaterial)&&(this.m_materialMap[e.name]=e)})),t.forEach((e=>{const t=this.makeBindingKey(e);if(this.m_materialSetterMap[t])return;const i=this.m_materialMap[e.materialName];if(!i)return;const n=this.getMaterialProperty(i,e.propertyName);if(!n||4!==e.targetValue.length)return;this.baseValueCache[t]=n,this.materialValuesToApply[t]=e;const a=r.Vector4.FromArray(e.targetValue),s=e.propertyName;if(i instanceof r.PBRMaterial?Object.keys(o).some((e=>s.startsWith(e)))&&(a.w*=-1):Object.keys(l).some((e=>s.startsWith(e)))&&(a.w*=-1),s.endsWith("_ST_S")){const e=(e,t)=>{const r=t?n.add(a.subtract(n).scale(e)):this.getMaterialProperty(i,s).add(a.subtract(n).scale(e)),o=this.getMaterialProperty(i,s);o.x=r.x,o.z=r.z,this.updateMaterialProperty(i,s,o)};this.m_materialSetterMap[t]=e}else if(s.endsWith("_ST_T")){const e=(e,t)=>{const r=t?n.add(a.subtract(n).scale(e)):this.getMaterialProperty(i,s).add(a.subtract(n).scale(e)),o=this.getMaterialProperty(i,s);o.y=r.y,o.w=r.w,this.updateMaterialProperty(i,s,o)};this.m_materialSetterMap[t]=e}else{const e=(e,t)=>{const r=t?n.add(a.subtract(n).scale(e)):this.getMaterialProperty(i,s).add(a.subtract(n).scale(e));this.updateMaterialProperty(i,s,r)};this.m_materialSetterMap[t]=e}})))}makeBindingKey(e){return`${e.materialName}_${e.propertyName}_${e.targetValue.join("-")}`}makeTargetKey(e){return`${e.materialName}_${e.propertyName}`}morphing(e){this.accumulateValue(e),this.apply()}accumulateValue(e){this.materialValues.forEach((t=>{const i=this.makeBindingKey(t);this.m_materialValueMap[i]?this.m_materialValueMap[i]+=e:this.m_materialValueMap[i]=e}))}apply(){this.m_used={},Object.entries(this.materialValuesToApply).forEach((([e,t])=>{const i=this.makeTargetKey(t);if(!(i in this.m_used)){const n=this.m_materialMap[t.materialName],r=this.baseValueCache[e].clone(),a=t.propertyName;if(a.endsWith("_ST_S")){const e=this.getMaterialProperty(n,a);r.y=e.y,r.w=e.w}else if(a.endsWith("_ST_T")){const e=this.getMaterialProperty(n,a);r.x=e.x,r.z=e.z}this.updateMaterialProperty(n,a,r),this.m_used[i]=!0}const n=this.m_materialSetterMap[e];n&&n(this.m_materialValueMap[e],!1)})),this.m_materialValueMap={}}getMaterialProperty(e,t){const i=t.match(/^(_[^_]+)/);if(!i||!i[1])return null;const n=i[1];return e instanceof r.PBRMaterial?o[n]?this.convertTextureIntoVector4WhenNotNull(e[o[n]]):s[n]?this.convertColorIntoVector4(e[s[n]],e.alpha):null:l[n]?this.convertTextureIntoVector4WhenNotNull(e[l[n]]):d[n]?this.convertColorIntoVector4(e[d[n]],e.alpha):null}convertTextureIntoVector4WhenNotNull(e){if(!e)return null;const t=e;return new r.Vector4(t.uScale,t.vScale,t.uOffset,t.vOffset)}convertColorIntoVector4(e,t){return new r.Vector4(e.r,e.g,e.b,t)}updateMaterialProperty(e,t,i){const n=t.match(/^(_[^_]+)/);if(!n||!n[1])return;const a=n[1];if(e instanceof r.PBRMaterial)return o[a]?void this.updateTextureWhenNotNull(e[o[a]],i):void(s[a]&&("_Color"===a&&(e.alpha=i.w),this.updateColor(e[s[a]],i)));l[a]?this.updateTextureWhenNotNull(e[l[a]],i):d[a]&&("_Color"===a&&(e.alpha=i.w),this.updateColor(e[d[a]],i))}updateTextureWhenNotNull(e,t){if(e){const i=e;i.uScale=t.x,i.vScale=t.y,i.uOffset=t.z,i.vOffset=t.w}}updateColor(e,t){e.r=t.x,e.g=t.y,e.b=t.z}}const f=LOADERS.GLTF2;var u;!function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(u||(u={}));class m{constructor(e){this.loader=e}generate(e,t,i,n,r){const o=this.findMaterialPropertyByName(t.name,this.getMaterialProperties());if(!o)return null;i.alphaIndex=o.renderQueue;const s=this.createMaterialByShader(e,t,n,o);return s?(r(s),s instanceof a.MToonMaterial?this.loadMToonTexturesAsync(e,s,o):Promise.resolve(s)):null}getMaterialProperties(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:[]:[]}findMaterialPropertyByName(e,t){if(!e||!t)return null;const i=t.filter((t=>t.name===e));return 0===i.length?null:(i.length>=2&&this.loader.log(`Duplicated vrm material name found: ${e}`),i[i.length-1])}loadMToonTexturesAsync(e,t,i){const n=[],r=i.vectorProperties._MainTex;if(!r)return Promise.resolve(t);const a=(t,i)=>{c(t,(a=>{n.push(this.loader.loadTextureInfoAsync(`${e}/textures/${t}`,{index:a},(e=>{const t=e;t.uOffset=r[0],t.vOffset=r[1],t.uScale=r[2],t.vScale=r[3],i(e)})))}))};return a(i.textureProperties._MainTex,(e=>{(t.alphaBlend||t.alphaTest)&&(e.hasAlpha=!0),t.diffuseTexture=e})),a(i.textureProperties._ShadeTexture,(e=>t.shadeTexture=e)),a(i.textureProperties._BumpMap,(e=>t.bumpTexture=e)),a(i.textureProperties._ReceiveShadowTexture,(e=>t.receiveShadowTexture=e)),a(i.textureProperties._ShadingGradeTexture,(e=>t.shadingGradeTexture=e)),a(i.textureProperties._RimTexture,(e=>t.rimTexture=e)),a(i.textureProperties._SphereAdd,(e=>t.matCapTexture=e)),a(i.textureProperties._EmissionMap,(e=>t.emissiveTexture=e)),a(i.textureProperties._OutlineWidthTexture,(e=>t.outlineWidthTexture=e)),a(i.textureProperties._UvAnimMaskTexture,(e=>t.uvAnimationMaskTexture=e)),Promise.all(n).then((()=>t))}createMaterialByShader(e,t,i,n){if(n.shader===u.VRMMToon){const e=new a.MToonMaterial(t.name||`MToonMaterial${t.index}`,this.loader.babylonScene);return this.setMToonMaterialProperties(e,n),e}if(n.shader===u.VRMUnlitTransparentZWrite){const n=this.loader.createMaterial(e,t,i);return n.disableDepthWrite=!1,n.forceDepthWrite=!0,n}return null}setMToonMaterialProperties(e,t){c(t.floatProperties._Cutoff,(t=>e.alphaCutOff=t)),c(t.vectorProperties._Color,(t=>{e.diffuseColor=new r.Color3(t[0],t[1],t[2]),e.alpha=t[3]})),c(t.vectorProperties._ShadeColor,(t=>{e.shadeColor=new r.Color3(t[0],t[1],t[2])})),c(t.floatProperties._BumpScale,(t=>e.bumpScale=t)),c(t.floatProperties._ReceiveShadowRate,(t=>e.receiveShadowRate=t)),c(t.floatProperties._ShadingGradeRate,(t=>e.shadingGradeRate=t)),c(t.floatProperties._ShadeShift,(t=>e.shadeShift=t)),c(t.floatProperties._ShadeToony,(t=>e.shadeToony=t)),c(t.floatProperties._LightColorAttenuation,(t=>e.lightColorAttenuation=t)),c(t.floatProperties._IndirectLightIntensity,(t=>e.indirectLightIntensity=t)),c(t.vectorProperties._RimColor,(t=>{e.rimColor=new r.Color3(t[0],t[1],t[2])})),c(t.floatProperties._RimLightingMix,(t=>e.rimLightingMix=t)),c(t.floatProperties._RimFresnelPower,(t=>e.rimFresnelPower=t)),c(t.floatProperties._RimLift,(t=>e.rimLift=t)),c(t.vectorProperties._EmissionColor,(t=>{e.emissiveColor=new r.Color3(t[0],t[1],t[2])})),c(t.floatProperties._OutlineWidth,(t=>e.outlineWidth=t)),c(t.floatProperties._OutlineScaledMaxDistance,(t=>e.outlineScaledMaxDistance=t)),c(t.vectorProperties._OutlineColor,(t=>{e.outlineColor=new r.Color3(t[0],t[1],t[2])})),c(t.floatProperties._OutlineLightingMix,(t=>e.outlineLightingMix=t)),c(t.floatProperties._UvAnimScrollX,(t=>e.uvAnimationScrollX=t)),c(t.floatProperties._UvAnimScrollY,(t=>e.uvAnimationScrollY=t)),c(t.floatProperties._UvAnimRotation,(t=>e.uvAnimationRotation=t)),c(t.floatProperties._DebugMode,(t=>e.debugMode=t)),c(t.floatProperties._BlendMode,(t=>{switch(t){case 0:e.alphaBlend=!1,e.alphaTest=!1;break;case 1:e.alphaBlend=!1,e.alphaTest=!0,e.alphaMode=r.Engine.ALPHA_COMBINE;break;case 2:e.alphaBlend=!0,e.alphaTest=!1,e.alphaMode=r.Engine.ALPHA_COMBINE}})),c(t.floatProperties._OutlineWidthMode,(t=>e.outlineWidthMode=t)),c(t.floatProperties._OutlineColorMode,(t=>e.outlineColorMode=t)),c(t.floatProperties._CullMode,(t=>e.cullMode=t)),c(t.floatProperties._OutlineCullMode,(t=>e.outlineCullMode=t)),c(t.keywordMap._ALPHABLEND_ON,(t=>e.alphaBlend=t)),c(t.keywordMap._ALPHATEST_ON,(t=>e.alphaTest=t)),c(t.floatProperties._ZWrite,(t=>{e.forceDepthWrite=1===Math.round(t),e.forceDepthWrite&&(e.disableDepthWrite=!1)}))}}function c(e,t){void 0!==e&&t(e)}const p="VCAST_vci_material_unity";class g{constructor(e){this.loader=e,this.name=p,this.enabled=!0}dispose(){this.loader=null}_loadMaterialAsync(e,t,i,n,r){return new m(this.loader).generate(e,t,i,n,r)}}f.GLTFLoader.RegisterExtension(p,(e=>new g(e)));class _{constructor(e,t,i){this.offset=e,this.radius=t,this.sphere=i}}class M{constructor(e){this.transform=e,this.colliders=[]}addCollider(e,t){const i=r.SphereBuilder.CreateSphere(`${this.transform.name}_ColliderSphere`,{segments:6,diameter:2*t,updatable:!0},this.transform.getScene());i.setParent(this.transform),i.setPositionWithLocalVector(e),i.setEnabled(!1),this.colliders.push(new _(e,t,i))}}const A=r.Matrix.Identity(),v=new r.Vector3,I=new r.Vector3,T=new r.Vector3,S=new r.Quaternion,E=new r.Matrix,x=new r.Matrix;class N{constructor(e,t,i){this.center=e,this.radius=t,this.transform=i,this.currentTail=new r.Vector3,this.prevTail=new r.Vector3,this.nextTail=new r.Vector3,i.rotationQuaternion||(i.rotationQuaternion=i.rotation.toQuaternion());const n=i.getWorldMatrix();this.centerSpacePosition=n.getTranslation(),this.initialLocalMatrix=i._localMatrix.clone(),this.initialLocalRotation=i.rotationQuaternion.clone();const a=i.getChildTransformNodes(!0);0===a.length?this.initialLocalChildPosition=i.position.clone().normalize().scaleInPlace(.07):this.initialLocalChildPosition=a[0].position.clone(),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,n,this.currentTail),this.prevTail.copyFrom(this.currentTail),this.nextTail.copyFrom(this.currentTail),this.boneAxis=this.initialLocalChildPosition.normalizeToNew(),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,n,v),this.centerSpaceBoneLength=v.subtractInPlace(this.centerSpacePosition).length(),e&&(this.getMatrixWorldToCenter(E),r.Vector3.TransformCoordinatesToRef(this.currentTail,E,this.currentTail),r.Vector3.TransformCoordinatesToRef(this.prevTail,E,this.prevTail),r.Vector3.TransformCoordinatesToRef(this.nextTail,E,this.nextTail),n.multiplyToRef(E,E),E.getTranslationToRef(this.centerSpacePosition),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,E,v),this.centerSpaceBoneLength=v.subtractInPlace(this.centerSpacePosition).length())}update(e,t,i,n){if(Number.isNaN(this.transform.getAbsolutePosition().x))return;this.getMatrixWorldToCenter(E),this.transform.getWorldMatrix().multiplyToRef(E,E),E.getTranslationToRef(this.centerSpacePosition),this.getMatrixWorldToCenter(x),this.getParentMatrixWorld().multiplyToRef(x,x),this.nextTail.copyFrom(this.currentTail),v.copyFrom(this.currentTail).subtractInPlace(this.prevTail).scaleInPlace(1-t),this.nextTail.addInPlace(v),v.copyFrom(this.boneAxis),r.Vector3.TransformCoordinatesToRef(v,this.initialLocalMatrix,v),r.Vector3.TransformCoordinatesToRef(v,x,v),v.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(e),this.nextTail.addInPlace(v),this.nextTail.addInPlace(i),this.nextTail.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition),this.collide(n,this.nextTail),this.prevTail.copyFrom(this.currentTail),this.currentTail.copyFrom(this.nextTail),this.initialLocalMatrix.multiplyToRef(x,E);const a=E.invert();r.Vector3.TransformCoordinatesToRef(this.nextTail,a,v),v.normalizeToRef(I),r.Quaternion.FromUnitVectorsToRef(this.boneAxis,I,S);const o=S;this.initialLocalRotation.multiplyToRef(o,this.transform.rotationQuaternion),this.transform.computeWorldMatrix(!0)}getMatrixWorldToCenter(e){return this.center?this.center.getWorldMatrix().invertToRef(e):e.copyFrom(A),e}getParentMatrixWorld(){return this.transform.parent?this.transform.parent.getWorldMatrix():A}collide(e,t){e.forEach((e=>{e.colliders.forEach((e=>{this.getMatrixWorldToCenter(E),e.sphere.computeWorldMatrix().multiplyToRef(E,E),E.getTranslationToRef(v);const i=v;let n=0;e.sphere.absoluteScaling.asArray().forEach((e=>{n=Math.max(n,Math.abs(e))}));const r=e.radius*n,a=this.radius+r;if(t.subtractToRef(i,I),I.lengthSquared()<=a*a){const e=I.copyFrom(t).subtractInPlace(i).normalize(),n=T.copyFrom(i).addInPlace(e.scaleInPlace(a));t.copyFrom(n.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition))}}))}))}}class D{constructor(e,t,i,n,r,a,o,s,l){this.comment=e,this.stiffness=t,this.gravityPower=i,this.gravityDir=n,this.dragForce=r,this.center=a,this.hitRadius=o,this.bones=s,this.colliderGroups=l,this.verlets=[],this.activeBones=[],this.drawGizmo=!1,this.activeBones=this.bones.filter((e=>null!==e)),this.activeBones.forEach((e=>{[e].concat(e.getChildTransformNodes()).forEach((e=>{this.verlets.push(new N(this.center,this.hitRadius,e))}))})),this.drawGizmo&&this.setupGizmo()}setupGizmo(){this.activeBones.forEach((e=>{const t=e.getScene();[e].concat(e.getChildTransformNodes()).forEach((e=>{const i=r.MeshBuilder.CreateSphere(e.name+"_boneGizmo",{segments:6,diameter:2*this.hitRadius,updatable:!0},t),n=new r.StandardMaterial(e.name+"_boneGizmomat",t);n.emissiveColor=r.Color3.Red(),n.wireframe=!0,i.material=n,i.setParent(e),i.position=r.Vector3.Zero()}))})),this.colliderGroups.forEach((e=>{const t=e.transform.getScene();e.colliders.forEach((i=>{const n=i.sphere;if(!n.isEnabled(!1)){n.setEnabled(!0);const i=new r.StandardMaterial(e.transform.name+"_colliderGizmomat",t);i.emissiveColor=r.Color3.Yellow(),i.wireframe=!0,n.material=i}}))}))}async update(e){const t=this.stiffness*e,i=this.gravityDir.scale(this.gravityPower*e),n=this.verlets.map((e=>new Promise((n=>{e.update(t,this.dragForce,i,this.colliderGroups),n()}))));return Promise.all(n).then((()=>{}))}}class C{constructor(e,t){this.ext=e;const i=this.constructColliderGroups(t);this.springs=this.constructSprings(t,i)}dispose(){this.springs=[]}async update(e){e=Math.max(0,Math.min(16.666,e))/1e3;const t=this.springs.map((t=>t.update(e)));return Promise.all(t).then((()=>{}))}constructColliderGroups(e){if(!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const t=[];return this.ext.colliderGroups.forEach((i=>{const n=e(i.node),a=new M(n);i.colliders.forEach((e=>{a.addCollider(new r.Vector3(-e.offset.x,e.offset.y,-e.offset.z),e.radius)})),t.push(a)})),t}constructSprings(e,t){if(!this.ext.boneGroups||!this.ext.boneGroups.length)return[];const i=[];return this.ext.boneGroups.forEach((n=>{const a=(n.bones||[]).map((t=>e(t))),o=(n.colliderGroups||[]).map((e=>t[e]));i.push(new D(n.comment,n.stiffiness,n.gravityPower,new r.Vector3(-n.gravityDir.x,n.gravityDir.y,-n.gravityDir.z).normalize(),n.dragForce,e(n.center),n.hitRadius,a,o))})),i}}class P{constructor(e,i,n,r,a){this.ext=e,this.scene=i,this.meshesFrom=n,this.transformNodesFrom=r,this.materialsNodesFrom=a,this.isBinaryMorphMap={},this.morphTargetMap={},this.materialValueBindingMergerMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache={},this.meshCache={},this.meshCache=this.constructMeshCache(),this.transformNodeCache=this.constructTransformNodeCache(),this.springBoneController=new C(this.ext.secondaryAnimation,this.findTransformNode.bind(this)),this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&(this.constructIsBinaryMap(),this.constructMorphTargetMap(),this.constructMaterialValueBindingMergerMap()),this.constructTransformNodeMap(),this._humanoidBone=new t(this.transformNodeMap)}async update(e){await this.springBoneController.update(e)}dispose(){this.springBoneController.dispose(),this._humanoidBone.dispose(),this.morphTargetMap=null,this.materialValueBindingMergerMap=null,this.presetMorphTargetMap=null,this.transformNodeMap=null,this.transformNodeCache=null,this.meshCache=null,this._rootMesh=null}morphing(e,t){const i=this.calcMorphValue(e,t);this.morphTargetMap[e]&&this.morphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)})),this.materialValueBindingMergerMap[e]&&this.materialValueBindingMergerMap[e].morphing(i)}morphingPreset(e,t){if(!this.presetMorphTargetMap[e])return;const i=this.calcMorphValue(e,t);this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)}))}calcMorphValue(e,t){const i=Math.max(0,Math.min(1,t));return this.isBinaryMorphMap[e]?i>.5?1:0:i}getMorphingList(){return Object.keys(this.morphTargetMap)}getFirstPersonCameraPosition(){const e=this.getFirstPersonBone();if(!e)return null;const t=e.getAbsolutePosition(),i=this.ext.firstPerson.firstPersonBoneOffset;return new r.Vector3(t.x+i.x,t.y+i.y,t.z+i.z)}getFirstPersonBone(){return this.findTransformNode(this.ext.firstPerson.firstPersonBone)}getBone(e){return this.transformNodeMap[e]||null}get humanoidBone(){return this._humanoidBone}get rootMesh(){return this._rootMesh}findTransformNode(e){return this.transformNodeCache[e]||null}findMesh(e){return this.meshCache[e]&&this.meshCache[e][0]||null}findMeshes(e){return this.meshCache[e]||null}constructIsBinaryMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{this.isBinaryMorphMap[e.name]=e.isBinary}))}constructMorphTargetMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{e.binds&&e.binds.forEach((t=>{const i=this.findMeshes(t.mesh);i?i.forEach((i=>{const n=i.morphTargetManager;if(!n)return void console.log("Undefined morphTargetManager",t);const r=n.getTarget(t.index);this.morphTargetMap[e.name]=this.morphTargetMap[e.name]||[],this.morphTargetMap[e.name].push({target:r,weight:t.weight}),e.presetName&&(this.presetMorphTargetMap[e.presetName]=this.presetMorphTargetMap[e.presetName]||[],this.presetMorphTargetMap[e.presetName].push({target:r,weight:t.weight}))})):console.log("Undefined BlendShapeBind Mesh",t)}))}))}constructMaterialValueBindingMergerMap(){const e=this.scene.materials.slice(this.materialsNodesFrom);this.ext.blendShapeMaster.blendShapeGroups.forEach((t=>{t.materialValues&&(this.materialValueBindingMergerMap[t.name]=new h(e,t.materialValues))}))}constructTransformNodeMap(){this.ext.humanoid.humanBones.forEach((e=>{const t=this.findTransformNode(e.node);t&&(this.transformNodeMap[e.bone]=t)}))}constructTransformNodeCache(){const e={};for(let t=this.transformNodesFrom;t<this.scene.transformNodes.length;t++){const i=this.scene.transformNodes[t];if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length||(i.metadata=i._internalMetadata),i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers)if(t.startsWith("/nodes/")){e[parseInt(t.substr(7),10)]=i;break}}return e}constructMeshCache(){const e={};for(let t=this.meshesFrom;t<this.scene.meshes.length;t++){const i=this.scene.meshes[t];if("__root__"!==i.id){if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length||(i.metadata=i._internalMetadata),i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers){const n=t.match(/^\/meshes\/(\d+).+$/);if(n){const t=parseInt(n[1],10);e[t]=e[t]||[],e[t].push(i);break}}}else this._rootMesh=i}return e}}class L{constructor(e){this.loader=e,this.name="VRM",this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.materialsFrom=0,this.meshesFrom=this.loader.babylonScene.meshes.length-1,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length,this.materialsFrom=this.loader.babylonScene.materials.length}dispose(){this.loader=null}onReady(){if(!this.loader.gltf.extensions||!this.loader.gltf.extensions.VRM)return;const e=this.loader.babylonScene,t=new P(this.loader.gltf.extensions.VRM,this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,this.materialsFrom);e.metadata=e.metadata||{},e.metadata.vrmManagers=e.metadata.vrmManagers||[],e.metadata.vrmManagers.push(t),this.loader.babylonScene.onDisposeObservable.add((()=>{t.dispose(),this.loader.babylonScene.metadata.vrmManagers=[]}))}_loadVertexDataAsync(e,t,i){return t.extras&&t.extras.targetNames?(i.metadata=i.metadata||{},i.metadata.vrmTargetNames=t.extras.targetNames,null):null}_loadMaterialAsync(e,t,i,n,r){return new m(this.loader).generate(e,t,i,n,r)}}f.GLTFLoader.RegisterExtension("VRM",(e=>new L(e)));const O=LOADERS;class R extends O.GLTFFileLoader{}class y{constructor(){this.name="vrm",this.extensions={".vrm":{isBinary:!0},".vci":{isBinary:!0}}}createPlugin(){return new R}}r.SceneLoader&&r.SceneLoader.RegisterPlugin(new y)})(),window.VRMLoader=n})();
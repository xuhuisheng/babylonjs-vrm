(()=>{var e={731:(e,t,i)=>{var n;self,n=(e,t,i,n,r,o,a,s,l,h,d,f,u,c,m,p,g,M,_)=>(()=>{"use strict";var T={908:e=>{e.exports=a},556:e=>{e.exports=f},272:e=>{e.exports=c},55:e=>{e.exports=u},677:e=>{e.exports=s},66:e=>{e.exports=l},824:e=>{e.exports=m},713:e=>{e.exports=_},221:e=>{e.exports=d},628:e=>{e.exports=p},721:e=>{e.exports=h},548:e=>{e.exports=o},694:e=>{e.exports=r},388:t=>{t.exports=e},680:e=>{e.exports=t},812:e=>{e.exports=g},474:e=>{e.exports=i},538:e=>{e.exports=n},667:e=>{e.exports=M}},v={};function I(e){var t=v[e];if(void 0!==t)return t.exports;var i=v[e]={exports:{}};return T[e](i,i.exports,I),i.exports}I.d=(e,t)=>{for(var i in t)I.o(t,i)&&!I.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:t[i]})},I.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),I.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var A={};return(()=>{function e(e,t,i,n){var r,o=arguments.length,a=o<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,i,n);else for(var s=e.length-1;s>=0;s--)(r=e[s])&&(a=(o<3?r(a):o>3?r(t,i,a):r(t,i))||a);return o>3&&a&&Object.defineProperty(t,i,a),a}I.r(A),I.d(A,{CullMode:()=>C,DebugMode:()=>x,MToonMaterial:()=>L,OutlineColorMode:()=>N,OutlineWidthMode:()=>P}),Object.create,Object.create;var t=I(388),i=I(680),n=I(474),r=I(538),o=I(694),a=I(548),s=I(908),l=I(677),h=I(66),d=I(721),f=I(221),u=I(556),c=I(55),m=I(272),p=I(824),g=I(628),M=I(812),_=I(667);class T{constructor(e,t){this.scene=e,this.material=t,this.name=`MToonOutline_${t.name}_${T.rendererId++}`,this.scene._addComponent(this),this._engine=this.scene.getEngine(),this._passIdForDrawWrapper=[];for(let e=0;e<1;++e)this._passIdForDrawWrapper[e]=this._engine.createRenderPassId(`Outline Renderer (${e})`)}register(){this.scene._afterRenderingMeshStage.registerStep(_.SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE,this,this._afterRenderingMesh)}rebuild(){}dispose(){for(let e=0;e<this._passIdForDrawWrapper.length;++e)this._engine.releaseRenderPassId(this._passIdForDrawWrapper[e])}render(e,t,i){i=null!=i?i:this._passIdForDrawWrapper[0];const n=this.scene,r=e.effect;if(!r||!r.isReady()||!this.scene.activeCamera)return;const o=e._getDrawWrapper(i,!0);if(!o)return;if(o.setEffect(r),!o.effect||!o.effect.isReady())return;const a=e.getMesh(),s=a._internalAbstractMeshDataInfo._actAsRegularMesh?a:null,l=e.getRenderingMesh(),h=s||l;n.activeCamera&&(this.material.applyOutlineCullMode(),this.material.enableOutlineRender(),this._engine.enableEffect(o),this.isHardwareInstancedRendering(e,t)||l._bind(e,r,this.material.fillMode),this.material._preBind(r),l._processRendering(h,e,r,this.material.fillMode,t,this.isHardwareInstancedRendering(e,t),((t,i,n)=>{n&&n.bindForSubMesh(i,h,e)}),this.material),this.material.restoreOutlineCullMode(),this.material.disaableOutlineRender())}_afterRenderingMesh(e,t,i){if(!this.willRender(t))return;const n=this._engine.cullBackFaces;this._engine.cullBackFaces=!1,this.render(t,i,this._passIdForDrawWrapper[0]),this._engine.cullBackFaces=n}isHardwareInstancedRendering(e,t){return!!this._engine.getCaps().instancedArrays&&null!==t.visibleInstances[e._id]&&void 0!==t.visibleInstances[e._id]&&e.getRenderingMesh().hasThinInstances}willRender(e){const t=e.getMaterial();return!(!t||"MToonMaterial"!==t.getClassName()||t.getOutlineRendererName()!==this.name)}}T.rendererId=0;var v=I(713);class S extends v.MaterialDefines{constructor(e){super(e),this.CUSTOMUSERLIGHTING=!0,this.MTOON_OUTLINE_WIDTH_WORLD=!1,this.MTOON_OUTLINE_WIDTH_SCREEN=!1,this.MTOON_OUTLINE_COLOR_FIXED=!1,this.MTOON_OUTLINE_COLOR_MIXED=!1,this.MTOON_DEBUG_NORMAL=!1,this.MTOON_DEBUG_LITSHADERRATE=!1,this.SHADE=!1,this.SHADEDIRECTUV=0,this.RECEIVE_SHADOW=!1,this.RECEIVE_SHADOWDIRECTUV=0,this.SHADING_GRADE=!1,this.SHADING_GRADEDIRECTUV=0,this.RIM=!1,this.RIMDIRECTUV=0,this.MATCAP=!1,this.MATCAPDIRECTUV=0,this.OUTLINE_WIDTH=!1,this.OUTLINE_WIDTHDIRECTUV=0,this.UV_ANIMATION_MASK=!1,this.UV_ANIMATION_MASKDIRECTUV=0,this.MAINUV1=!1,this.MAINUV2=!1,this.MAINUV3=!1,this.MAINUV4=!1,this.MAINUV5=!1,this.MAINUV6=!1,this.DIFFUSE=!1,this.DIFFUSEDIRECTUV=0,this.BAKED_VERTEX_ANIMATION_TEXTURE=!1,this.EMISSIVE=!1,this.EMISSIVEDIRECTUV=0,this.BUMP=!1,this.BUMPDIRECTUV=0,this.PARALLAX=!1,this.PARALLAXOCCLUSION=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.ALPHATEST=!1,this.DEPTHPREPASS=!1,this.ALPHAFROMDIFFUSE=!1,this.POINTSIZE=!1,this.FOG=!1,this.NORMAL=!1,this.UV1=!1,this.UV2=!1,this.UV3=!1,this.UV4=!1,this.UV5=!1,this.UV6=!1,this.VERTEXCOLOR=!1,this.VERTEXALPHA=!1,this.NUM_BONE_INFLUENCERS=0,this.BonesPerMesh=0,this.BONETEXTURE=!1,this.BONES_VELOCITY_ENABLED=!1,this.INSTANCES=!1,this.THIN_INSTANCES=!1,this.OBJECTSPACE_NORMALMAP=!1,this.LOGARITHMICDEPTH=!1,this.TWOSIDEDLIGHTING=!1,this.SHADOWFLOAT=!1,this.MORPHTARGETS=!1,this.MORPHTARGETS_NORMAL=!1,this.MORPHTARGETS_TANGENT=!1,this.MORPHTARGETS_UV=!1,this.NUM_MORPH_INFLUENCERS=0,this.MORPHTARGETS_POSITION=!0,this.MORPHTARGETTEXTURE_HASPOSITIONS=!0,this.MORPHTARGETS_TEXTURE=!1,this.NONUNIFORMSCALING=!1,this.PREMULTIPLYALPHA=!1,this.ALPHATEST_AFTERALLALPHACOMPUTATIONS=!1,this.ALPHABLEND=!0,this.PREPASS=!1,this.PREPASS_IRRADIANCE=!1,this.PREPASS_IRRADIANCE_INDEX=-1,this.PREPASS_ALBEDO_SQRT=!1,this.PREPASS_ALBEDO_SQRT_INDEX=-1,this.PREPASS_DEPTH=!1,this.PREPASS_DEPTH_INDEX=-1,this.PREPASS_NORMAL=!1,this.PREPASS_NORMAL_INDEX=-1,this.PREPASS_POSITION=!1,this.PREPASS_POSITION_INDEX=-1,this.PREPASS_VELOCITY=!1,this.PREPASS_VELOCITY_INDEX=-1,this.PREPASS_REFLECTIVITY=!1,this.PREPASS_REFLECTIVITY_INDEX=-1,this.SCENE_MRT_COUNT=0,this.IMAGEPROCESSING=!1,this.VIGNETTE=!1,this.VIGNETTEBLENDMODEMULTIPLY=!1,this.VIGNETTEBLENDMODEOPAQUE=!1,this.TONEMAPPING=0,this.TONEMAPPING_ACES=!1,this.CONTRAST=!1,this.COLORCURVES=!1,this.COLORGRADING=!1,this.COLORGRADING3D=!1,this.SAMPLER3DGREENDEPTH=!1,this.SAMPLER3DBGRMAP=!1,this.IMAGEPROCESSINGPOSTPROCESS=!1,this.SKIPFINALCOLORCLAMP=!1,this.MULTIVIEW=!1,this.ORDER_INDEPENDENT_TRANSPARENCY=!1,this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!1,this.DITHER=!1,this.IS_REFLECTION_LINEAR=!1,this.IS_REFRACTION_LINEAR=!1,this.EXPOSURE=!1,this.FLIP_U=!1,this.FLIP_V=!1,this.rebuild()}setReflectionMode(e){throw new Error("This material cannot use `setReflectionMode`")}}const E={effect:null,subMesh:null};var x,N,P,C;!function(e){e[e.None=0]="None",e[e.Normal=1]="Normal",e[e.LitShadeRate=2]="LitShadeRate"}(x||(x={})),function(e){e[e.FixedColor=0]="FixedColor",e[e.MixedLighting=1]="MixedLighting"}(N||(N={})),function(e){e[e.None=0]="None",e[e.WorldCorrdinates=1]="WorldCorrdinates",e[e.ScreenCoordinates=2]="ScreenCoordinates"}(P||(P={})),function(e){e[e.Off=0]="Off",e[e.Front=1]="Front",e[e.Back=2]="Back"}(C||(C={}));class L extends d.PushMaterial{constructor(e,t){super(e,t),this._diffuseTexture=null,this.diffuseTexture=null,this._emissiveTexture=null,this.emissiveTexture=null,this._bumpTexture=null,this.bumpTexture=null,this._shadeTexture=null,this.shadeTexture=null,this._receiveShadowTexture=null,this.receiveShadowTexture=null,this._shadingGradeTexture=null,this.shadingGradeTexture=null,this._rimTexture=null,this.rimTexture=null,this._matCapTexture=null,this.matCapTexture=null,this._outlineWidthTexture=null,this.outlineWidthTexture=null,this._uvAnimationMaskTexture=null,this.uvAnimationMaskTexture=null,this.diffuseColor=new a.Color3(1,1,1),this.ambientColor=new a.Color3(0,0,0),this.emissiveColor=new a.Color3(0,0,0),this.shadeColor=new a.Color3(.97,.81,.86),this.rimColor=new a.Color3(0,0,0),this.outlineColor=new a.Color3(0,0,0),this.useEmissiveAsIllumination=!1,this.linkEmissiveWithDiffuse=!1,this.useReflectionOverAlpha=!1,this._disableLighting=!1,this.useObjectSpaceNormalMap=!1,this.useParallax=!1,this.useParallaxOcclusion=!1,this.specularSupported=!1,this.useLightmapAsShadowmap=!1,this.useVertexColor=!1,this.useBones=!0,this.useMorphTargets=!0,this.useVertexAlpha=!1,this.useBakedVertexAnimation=!1,this.alphaCutOff=.4,this._useAlphaFromDiffuseTexture=!0,this._maxSimultaneousLights=4,this._invertNormalMapX=!0,this._invertNormalMapY=!0,this._twoSidedLighting=!1,this._renderTargets=new n.SmartArray(16),this._worldViewProjectionMatrix=o.Matrix.Zero(),this._globalAmbientColor=new a.Color3(0,0,0),this._cacheHasRenderTargetTextures=!1,this._bumpScale=1,this._receiveShadowRate=1,this._shadingGradeRate=1,this._shadeShift=0,this._shadeToony=.9,this._lightColorAttenuation=0,this._indirectLightIntensity=.1,this._rimLightingMix=0,this._rimFresnelPower=1,this._rimLift=0,this._outlineWidth=.5,this._outlineScaledMaxDistance=1,this._outlineLightingMix=1,this._uvAnimationScrollX=0,this._uvAnimationScrollY=0,this._uvAnimationRotation=0,this._alphaTest=!1,this._alphaBlend=!1,this._debugMode=x.None,this.debugMode=x.None,this._outlineWidthMode=P.None,this.isOutline=0,this.outlineColorMode=N.MixedLighting,this._cullMode=C.Back,this._outlineCullMode=C.Front,this.outlineCullMode=C.Front,this.storedCullMode=C.Back,this.flipU=!1,this.flipV=!1,this.detailMap=new p.DetailMapConfiguration(this),this._attachImageProcessingConfiguration(null),this.getRenderTargetTextures=()=>(this._renderTargets.reset(),this._eventInfo.renderTargets=this._renderTargets,this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),this._renderTargets),m.Effect.IncludesShadersStore.mtoonUboDeclaration||(m.Effect.IncludesShadersStore.mtoonUboDeclaration="// it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n\nlayout(std140, column_major) uniform;\n\nuniform Material\n{\n    // Color & Texture\n    vec4 vDiffuseColor;\n    vec2 vDiffuseInfos;\n    mat4 diffuseMatrix;\n    vec4 vEmissiveColor;\n    vec2 vEmissiveInfos;\n    mat4 emissiveMatrix;\n    vec3 vBumpInfos;\n    mat4 bumpMatrix;\n    vec3 vShadeColor;\n    vec2 vShadeInfos;\n    mat4 shadeMatrix;\n    vec2 vReceiveShadowInfos;\n    mat4 receiveShadowMatrix;\n    vec2 vShadingGradeInfos;\n    mat4 shadingGradeMatrix;\n    vec3 vRimColor;\n    vec2 vRimInfos;\n    mat4 rimMatrix;\n    vec2 vMatCapInfos;\n    mat4 matCapMatrix;\n    vec4 vOutlineColor;\n    vec2 vOutlineWidthInfos;\n    mat4 outlineWidthMatrix;\n    vec2 vUvAnimationMaskInfos;\n    mat4 uvAnimationMaskMatrix;\n\n    // babylon specific\n    vec2 vTangentSpaceParams;\n    float pointSize;\n\n    // MToon params\n    float shadingGradeRate;\n    float receiveShadowRate;\n    float shadeShift;\n    float shadeToony;\n    float lightColorAttenuation;\n    float indirectLightIntensity;\n    float rimLightingMix;\n    float rimFresnelPower;\n    float rimLift;\n    float outlineWidth;\n    float outlineScaledMaxDistance;\n    float outlineLightingMix;\n    float uvAnimationScrollX;\n    float uvAnimationScrollY;\n    float uvAnimationRotation;\n\n    vec3 vEyeUp;\n    float alphaCutOff;\n    vec3 vAmbientColor;\n    float aspect;\n    float isOutline;\n    vec4 time;\n};\n\n// babylon specific\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n",m.Effect.IncludesShadersStore.mtoonVertexDeclaration="// Uniforms\nuniform mat4 viewProjection;\nuniform mat4 view;\nuniform mat4 projection;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float isOutline;\nuniform float aspect;\n\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\nuniform mat4 emissiveMatrix;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform mat4 bumpMatrix;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\nuniform mat4 shadeMatrix;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\nuniform mat4 receiveShadowMatrix;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\nuniform mat4 shadingGradeMatrix;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\nuniform mat4 rimMatrix;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\nuniform mat4 matCapMatrix;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\nuniform mat4 outlineWidthMatrix;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\nuniform mat4 uvAnimationMaskMatrix;\n#endif\n\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n",m.Effect.IncludesShadersStore.mtoonFragmentDeclaration="uniform vec4 vEyePosition;\n\n// Colors\nuniform vec4 vDiffuseColor;\nuniform vec3 vEmissiveColor;\nuniform vec3 vShadeColor;\nuniform vec3 vRimColor;\nuniform vec4 vOutlineColor;\nuniform vec3 vAmbientColor;\n\nuniform vec3 vEyeUp;\nuniform float aspect;\nuniform float alphaCutOff;\nuniform float visibility;\nuniform float isOutline;\nuniform vec4 time;\n\n// Samplers\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n\n#ifdef BUMP\nuniform vec3 vBumpInfos;\nuniform vec2 vTangentSpaceParams;\n#endif\n\n#ifdef SHADE\nuniform vec2 vShadeInfos;\n#endif\n\n#ifdef RECEIVE_SHADOW\nuniform vec2 vReceiveShadowInfos;\n#endif\n\n#ifdef SHADING_GRADE\nuniform vec2 vShadingGradeInfos;\n#endif\n\n#ifdef RIM\nuniform vec2 vRimInfos;\n#endif\n\n#ifdef MATCAP\nuniform vec2 vMatCapInfos;\n#endif\n\n#ifdef OUTLINE_WIDTH\nuniform vec2 vOutlineWidthInfos;\n#endif\n\n#ifdef UV_ANIMATION_MASK\nuniform vec2 vUvAnimationMaskInfos;\n#endif\n\n// MToon params\nuniform float shadingGradeRate;\nuniform float receiveShadowRate;\nuniform float shadeShift;\nuniform float shadeToony;\nuniform float lightColorAttenuation;\nuniform float indirectLightIntensity;\nuniform float rimLightingMix;\nuniform float rimFresnelPower;\nuniform float rimLift;\nuniform float outlineWidth;\nuniform float outlineScaledMaxDistance;\nuniform float outlineLightingMix;\nuniform float uvAnimationScrollX;\nuniform float uvAnimationScrollY;\nuniform float uvAnimationRotation;\n",m.Effect.IncludesShadersStore.mtoonFragmentFunctions="\n/**\n* Compute Directional or Point light direction\n*/\nvec3 computeLightDirection(vec4 lightData) {\n    return normalize(mix(lightData.xyz - vPositionW, -lightData.xyz, lightData.w));\n}\n\n/**\n* Compute Spot Light direction\n*/\nvec3 computeSpotLightDirection(vec4 lightData) {\n    return normalize(lightData.xyz - vPositionW);\n}\n\n/**\n* Compute Hemispheric light direction\n*/\nvec3 computeHemisphericLightDirection(vec4 lightData, vec3 vNormal) {\n    return normalize(lightData.xyz);\n}\n\n/**\n* Compute MToon diffuse lighting\n*/\nvec4 computeMToonDiffuseLighting(vec3 worldView, vec3 worldNormal, vec2 mainUv, vec3 lightDirection, vec4 lightDiffuse, float shadowAttenuation) {\n    float _receiveShadow = receiveShadowRate;\n#ifdef RECEIVE_SHADOW\n    _receiveShadow = _receiveShadow * texture2D(receiveShadowSampler, mainUv).r * vReceiveShadowInfos.y;\n#endif\n\n    float _shadingGrade = 0.0;\n#ifdef SHADING_GRADE\n    _shadingGrade = 1.0 - texture2D(shadingGradeSampler, mainUv).r * vShadingGradeInfos.y;\n#endif\n    _shadingGrade = 1.0 - shadingGradeRate * _shadingGrade;\n\n    // Lighting\n    vec3 _lightColor = lightDiffuse.rgb * step(0.5, length(lightDirection)); // length(lightDir) is zero if directional light is disabled.\n    float _dotNL = dot(lightDirection, worldNormal);\n#ifdef MTOON_FORWARD_ADD\n    float _lightAttenuation = 1.0;\n#else\n    float _lightAttenuation = shadowAttenuation * mix(1.0, shadowAttenuation, _receiveShadow);\n#endif\n\n    // lighting intensity\n    float _lightIntensity = _dotNL;\n    _lightIntensity = _lightIntensity * 0.5 + 0.5; // from [-1, +1] to [0, 1]\n    _lightIntensity = _lightIntensity * _lightAttenuation; // receive shadow\n    _lightIntensity = _lightIntensity * _shadingGrade; // darker\n    _lightIntensity = _lightIntensity * 2.0 - 1.0; // from [0, 1] to [-1, +1]\n    // tooned. mapping from [minIntensityThreshold, maxIntensityThreshold] to [0, 1]\n    float _maxIntensityThreshold = mix(1.0, shadeShift, shadeToony);\n    float _minIntensityThreshold = shadeShift;\n    _lightIntensity = clamp((_lightIntensity - _minIntensityThreshold) / max(EPS_COL, (_maxIntensityThreshold - _minIntensityThreshold)), 0.0, 1.0);\n\n    // Albedo color\n    vec3 _shade = vShadeColor;\n#ifdef SHADE\n    _shade = _shade * texture2D(shadeSampler, mainUv).rgb * vShadeInfos.y;\n#endif\n\n    vec4 _lit = vDiffuseColor;\n#ifdef DIFFUSE\n    _lit = _lit * texture2D(diffuseSampler, mainUv) * vDiffuseInfos.y;\n#endif\n    vec3 _col = mix(_shade.rgb, _lit.rgb, _lightIntensity);\n\n    // Direct Light\n    vec3 _lighting = _lightColor;\n    _lighting = mix(_lighting, vec3(max(EPS_COL, max(_lighting.x, max(_lighting.y, _lighting.z)))), lightColorAttenuation); // color atten\n#ifdef MTOON_FORWARD_ADD\n    _lighting *= 0.5; // darken if additional light\n    _lighting *= min(0, dotNL) + 1.0; // darken dotNL < 0 area by using half lambert\n    _lighting *= shadowAttenuation; // darken if receiving shadow\n#else\n    // base light does not darken.\n#endif\n    _col *= _lighting;\n\n    // Indirect Light\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _toonedGI = vAmbientColor.rgb; // TODO: GI\n    vec3 _indirectLighting = mix(_toonedGI, vAmbientColor.rgb, indirectLightIntensity);\n    _indirectLighting = mix(_indirectLighting, vec3(max(EPS_COL, max(_indirectLighting.x, max(_indirectLighting.y, _indirectLighting.z)))), lightColorAttenuation); // color atten\n    _col += _indirectLighting * _lit.rgb;\n\n    _col = min(_col.rgb, _lit.rgb); // comment out if you want to PBR absolutely.\n#endif\n\n    // parametric rim lighting\n#ifdef MTOON_FORWARD_ADD\n    vec3 _staticRimLighting = vec3(0.0);\n    vec3 _mixedRimLighting = _lighting;\n#else\n    vec3 _staticRimLighting = vec3(1.0);\n    vec3 _mixedRimLighting = _lighting + _indirectLighting;\n#endif\n    vec3 _rimLighting = mix(_staticRimLighting, _mixedRimLighting, rimLightingMix);\n    vec3 _rimColor = vRimColor.rgb;\n#ifdef RIM\n    _rimColor = _rimColor * texture2D(rimSampler, vRimUV + mainUv).rgb * vRimInfos.y;\n#endif\n    vec3 _rim = pow(clamp(1.0 - dot(worldNormal, worldView) + rimLift, 0.0, 1.0), rimFresnelPower) * _rimColor.rgb;\n    _col += mix(_rim * _rimLighting, vec3(0.0), isOutline);\n\n    // additive matcap\n#ifdef MTOON_FORWARD_ADD\n#else\n#ifdef MATCAP\n    vec3 _worldViewUp = normalize(vEyeUp - worldView * dot(worldView, vEyeUp));\n    vec3 _worldViewRight = normalize(cross(worldView, _worldViewUp));\n    vec2 _matCapUv = vec2(dot(_worldViewRight, worldNormal), dot(_worldViewUp, worldNormal)) * 0.5 + 0.5;\n    // uv.y is reversed\n    _matCapUv.y = (1.0 - _matCapUv.y);\n    vec3 _matCapLighting = texture2D(matCapSampler, _matCapUv).rgb * vMatCapInfos.y;\n    _col += mix(_matCapLighting, vec3(0.0), isOutline);\n#endif\n#endif\n\n    // Emission\n#ifdef MTOON_FORWARD_ADD\n#else\n    vec3 _emission = vEmissiveColor.rgb;\n#ifdef EMISSIVE\n    _emission *= texture2D(emissiveSampler, mainUv).rgb * vEmissiveInfos.y;\n#endif\n    _col += mix(_emission, vec3(0.0), isOutline);\n#endif\n\n    float _alpha = 1.0;\n\n#if defined(ALPHABLEND) || defined(ALPHATEST)\n    _alpha = mix(_lit.a, _lit.a * vOutlineColor.a, isOutline);\n#endif\n\n    // outline\n#ifdef MTOON_OUTLINE_COLOR_FIXED\n    _col = mix(_col, vOutlineColor.rgb, isOutline);\n#elif defined(MTOON_OUTLINE_COLOR_MIXED)\n    _col = mix(_col, vOutlineColor.rgb * mix(vec3(1.0), _col, outlineLightingMix), isOutline);\n#else\n#endif\n\n    // debug\n#ifdef MTOON_DEBUG_NORMAL\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(worldNormal * 0.5 + 0.5, _lit.a);\n    #endif\n#elif defined(MTOON_DEBUG_LITSHADERATE)\n    #ifdef MTOON_FORWARD_ADD\n        return vec4(0.0);\n    #else\n        return vec4(_lightIntensity, _lit.a);\n    #endif\n#endif\n\n    return vec4(_col, _alpha);\n}\n",m.Effect.IncludesShadersStore.mtoonLightFragment="#ifdef LIGHT{X}\n    #if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n        //No light calculation\n    #else\n        #ifdef PBR\n            // Compute Pre Lighting infos\n            #ifdef SPOTLIGHT{X}\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(POINTLIGHT{X})\n                preInfo = computePointAndSpotPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(HEMILIGHT{X})\n                preInfo = computeHemisphericPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #elif defined(DIRLIGHT{X})\n                preInfo = computeDirectionalPreLightingInfo(light{X}.vLightData, viewDirectionW, normalW);\n            #endif\n\n            preInfo.NdotV = NdotV;\n\n            // Compute Attenuation infos\n            #ifdef SPOTLIGHT{X}\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                    preInfo.attenuation *= computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                    preInfo.attenuation *= computeDirectionalLightFalloff(light{X}.vLightDirection.xyz, preInfo.L, light{X}.vLightDirection.w, light{X}.vLightData.w, light{X}.vLightFalloff.z, light{X}.vLightFalloff.w);\n                #endif\n            #elif defined(POINTLIGHT{X})\n                #ifdef LIGHT_FALLOFF_GLTF{X}\n                    preInfo.attenuation = computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared, light{X}.vLightFalloff.y);\n                #elif defined(LIGHT_FALLOFF_PHYSICAL{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n                #elif defined(LIGHT_FALLOFF_STANDARD{X})\n                    preInfo.attenuation = computeDistanceLightFalloff_Standard(preInfo.lightOffset, light{X}.vLightFalloff.x);\n                #else\n                    preInfo.attenuation = computeDistanceLightFalloff(preInfo.lightOffset, preInfo.lightDistanceSquared, light{X}.vLightFalloff.x, light{X}.vLightFalloff.y);\n                #endif\n            #else\n                preInfo.attenuation = 1.0;\n            #endif\n\n            // Simulates Light radius for diffuse and spec term\n            // clear coat is using a dedicated roughness\n            #ifdef HEMILIGHT{X}\n                preInfo.roughness = roughness;\n            #else\n                preInfo.roughness = adjustRoughnessFromLightProperties(roughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n            #endif\n\n            // Diffuse contribution\n            #ifdef HEMILIGHT{X}\n                info.diffuse = computeHemisphericDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb, light{X}.vLightGround);\n            #elif defined(SS_TRANSLUCENCY)\n                info.diffuse = computeDiffuseAndTransmittedLighting(preInfo, light{X}.vLightDiffuse.rgb, subSurfaceOut.transmittance);\n            #else\n                info.diffuse = computeDiffuseLighting(preInfo, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Specular contribution\n            #ifdef SPECULARTERM\n                #ifdef ANISOTROPIC\n                    info.specular = computeAnisotropicSpecularLighting(preInfo, viewDirectionW, normalW, anisotropicOut.anisotropicTangent, anisotropicOut.anisotropicBitangent, anisotropicOut.anisotropy, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #else\n                    info.specular = computeSpecularLighting(preInfo, normalW, clearcoatOut.specularEnvironmentR0, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n                #endif\n            #endif\n\n            // Sheen contribution\n            #ifdef SHEEN\n                #ifdef SHEEN_LINKWITHALBEDO\n                    // BE Carefull: Sheen intensity is replacing the roughness value.\n                    preInfo.roughness = sheenOut.sheenIntensity;\n                #else\n                    #ifdef HEMILIGHT{X}\n                        preInfo.roughness = sheenOut.sheenRoughness;\n                    #else\n                        preInfo.roughness = adjustRoughnessFromLightProperties(sheenOut.sheenRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                    #endif\n                #endif\n                info.sheen = computeSheenLighting(preInfo, normalW, sheenOut.sheenColor, specularEnvironmentR90, AARoughnessFactors.x, light{X}.vLightDiffuse.rgb);\n            #endif\n\n            // Clear Coat contribution\n            #ifdef CLEARCOAT\n                // Simulates Light radius\n                #ifdef HEMILIGHT{X}\n                    preInfo.roughness = clearcoatOut.clearCoatRoughness;\n                #else\n                    preInfo.roughness = adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness, light{X}.vLightSpecular.a, preInfo.lightDistance);\n                #endif\n\n                info.clearCoat = computeClearCoatLighting(preInfo, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatAARoughnessFactors.x, clearcoatOut.clearCoatIntensity, light{X}.vLightDiffuse.rgb);\n\n                #ifdef CLEARCOAT_TINT\n                    // Absorption\n                    absorption = computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract, preInfo.L, clearcoatOut.clearCoatNormalW, clearcoatOut.clearCoatColor, clearcoatOut.clearCoatThickness, clearcoatOut.clearCoatIntensity);\n                    info.diffuse *= absorption;\n                    #ifdef SPECULARTERM\n                        info.specular *= absorption;\n                    #endif\n                #endif\n\n                // Apply energy conservation on diffuse and specular term.\n                info.diffuse *= info.clearCoat.w;\n                #ifdef SPECULARTERM\n                    info.specular *= info.clearCoat.w;\n                #endif\n                #ifdef SHEEN\n                    info.sheen *= info.clearCoat.w;\n                #endif\n            #endif\n        #else\n            #ifdef SPOTLIGHT{X}\n                info = computeSpotLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDirection, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #elif defined(HEMILIGHT{X})\n                info = computeHemisphericLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightGround, glossiness);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                info = computeLighting(viewDirectionW, normalW, light{X}.vLightData, light{X}.vLightDiffuse.rgb, light{X}.vLightSpecular.rgb, light{X}.vLightDiffuse.a, glossiness);\n            #endif\n        #endif\n\n        #ifdef PROJECTEDLIGHTTEXTURE{X}\n            info.diffuse *= computeProjectionTextureDiffuseLighting(projectionLightSampler{X}, textureProjectionMatrix{X});\n        #endif\n    #endif\n\n    #ifdef SHADOW{X}\n        #ifdef SHADOWCSM{X}\n            for (int i = 0; i < SHADOWCSMNUM_CASCADES{X}; i++)\n            {\n                #ifdef SHADOWCSM_RIGHTHANDED{X}\n                    diff{X} = viewFrustumZ{X}[i] + vPositionFromCamera{X}.z;\n                #else\n                    diff{X} = viewFrustumZ{X}[i] - vPositionFromCamera{X}.z;\n                #endif\n                if (diff{X} >= 0.) {\n                    index{X} = i;\n                    break;\n                }\n            }\n\n            #ifdef SHADOWCSMUSESHADOWMAXZ{X}\n            if (index{X} >= 0)\n            #endif\n            {\n                #if defined(SHADOWPCF{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #else\n                        shadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                    #endif\n                #elif defined(SHADOWPCSS{X})\n                    #if defined(SHADOWLOWQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #elif defined(SHADOWMEDIUMQUALITY{X})\n                        shadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #else\n                        shadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                    #endif\n                #else\n                    shadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                #endif\n\n                #ifdef SHADOWCSMDEBUG{X}\n                    shadowDebug{X} = vec3(shadow) * vCascadeColorsMultiplier{X}[index{X}];\n                #endif\n\n                #ifndef SHADOWCSMNOBLEND{X}\n                    float frustumLength = frustumLengths{X}[index{X}];\n                    float diffRatio = clamp(diff{X} / frustumLength, 0., 1.) * cascadeBlendFactor{X};\n                    if (index{X} < (SHADOWCSMNUM_CASCADES{X} - 1) && diffRatio < 1.)\n                    {\n                        index{X} += 1;\n                        float nextShadow = 0.;\n                        #if defined(SHADOWPCF{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF1(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCF3(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #else\n                                nextShadow = computeShadowWithCSMPCF5(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                            #endif\n                        #elif defined(SHADOWPCSS{X})\n                            #if defined(SHADOWLOWQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS16(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #elif defined(SHADOWMEDIUMQUALITY{X})\n                                nextShadow = computeShadowWithCSMPCSS32(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #else\n                                nextShadow = computeShadowWithCSMPCSS64(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w, lightSizeUVCorrection{X}[index{X}], depthCorrection{X}[index{X}], penumbraDarkness{X});\n                            #endif\n                        #else\n                            nextShadow = computeShadowCSM(float(index{X}), vPositionFromLight{X}[index{X}], vDepthMetric{X}[index{X}], shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n                        #endif\n\n                        shadow = mix(nextShadow, shadow, diffRatio);\n                        #ifdef SHADOWCSMDEBUG{X}\n                            shadowDebug{X} = mix(vec3(nextShadow) * vCascadeColorsMultiplier{X}[index{X}], shadowDebug{X}, diffRatio);\n                        #endif\n                    }\n                #endif\n            }\n        #elif defined(SHADOWCLOSEESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithCloseESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithCloseESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWESM{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithESMCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithESM(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.z, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPOISSON{X})\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadowWithPoissonSampling(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCF{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCF1(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCF3(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCF5(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.yz, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #elif defined(SHADOWPCSS{X})\n            #if defined(SHADOWLOWQUALITY{X})\n                shadow = computeShadowWithPCSS16(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #elif defined(SHADOWMEDIUMQUALITY{X})\n                shadow = computeShadowWithPCSS32(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #else\n                shadow = computeShadowWithPCSS64(vPositionFromLight{X}, vDepthMetric{X}, depthSampler{X}, shadowSampler{X}, light{X}.shadowsInfo.y, light{X}.shadowsInfo.z, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #else\n            #if defined(SHADOWCUBE{X})\n                shadow = computeShadowCube(light{X}.vLightData.xyz, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.depthValues);\n            #else\n                shadow = computeShadow(vPositionFromLight{X}, vDepthMetric{X}, shadowSampler{X}, light{X}.shadowsInfo.x, light{X}.shadowsInfo.w);\n            #endif\n        #endif\n\n        #ifdef SHADOWONLY\n            #ifndef SHADOWINUSE\n                #define SHADOWINUSE\n            #endif\n            globalShadow += shadow;\n            shadowLightCount += 1.0;\n        #endif\n    #else\n        shadow = 1.;\n    #endif\n\n    #ifndef SHADOWONLY\n        #ifdef CUSTOMUSERLIGHTING\n            // Compute and reflect MToon lighting\n            #ifdef SPOTLIGHT{X}\n                lightDirection = computeSpotLightDirection(light{X}.vLightData);\n            #elif defined(HEMILIGHT{X})\n                lightDirection = computeHemisphericLightDirection(light{X}.vLightData, normalW.xyz);\n            #elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\n                lightDirection = computeLightDirection(light{X}.vLightData);\n            #endif\n            mtoonDiffuse = computeMToonDiffuseLighting(viewDirectionW.xyz, normalW.xyz, mainUv, lightDirection, light{X}.vLightDiffuse.rgba, shadow);\n            diffuseBase += mtoonDiffuse.rgb;\n            alpha = min(alpha, mtoonDiffuse.a);\n            #if defined(ALPHATEST) && ALPHATEST\n                alpha = (alpha - alphaCutOff) / max(fwidth(alpha), EPS_COL) + 0.5; // Alpha to Coverage\n                if (alpha < alphaCutOff) {\n                    discard;\n                }\n                alpha = 1.0; // Discarded, otherwise it should be assumed to have full opacity\n            #else\n                if (alpha - 0.0001 < 0.000) { // Slightly improves rendering with layered transparency\n                    discard;\n                }\n            #endif\n        #elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\n            diffuseBase += lightmapColor.rgb * shadow;\n            #ifdef SPECULARTERM\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    specularBase += info.specular * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef CLEARCOAT\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    clearCoatBase += info.clearCoat.rgb * shadow * lightmapColor.rgb;\n                #endif\n            #endif\n            #ifdef SHEEN\n                #ifndef LIGHTMAPNOSPECULAR{X}\n                    sheenBase += info.sheen.rgb * shadow;\n                #endif\n            #endif\n        #else\n            #ifdef SHADOWCSMDEBUG{X}\n                diffuseBase += info.diffuse * shadowDebug{X};\n            #else\n                diffuseBase += info.diffuse * shadow;\n            #endif\n            #ifdef SPECULARTERM\n                specularBase += info.specular * shadow;\n            #endif\n            #ifdef CLEARCOAT\n                clearCoatBase += info.clearCoat.rgb * shadow;\n            #endif\n            #ifdef SHEEN\n                sheenBase += info.sheen.rgb * shadow;\n            #endif\n        #endif\n    #endif\n#endif\n",m.Effect.IncludesShadersStore.mtoonBumpFragment="// replace vBumpUV to mainUv\nvec2 uvOffset = vec2(0.0, 0.0);\n\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n    #ifdef NORMALXYSCALE\n        float normalScale = 1.0;\n    #elif defined(BUMP)\n        float normalScale = vBumpInfos.y;\n    #else\n        float normalScale = 1.0;\n    #endif\n\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #elif defined(BUMP)\n        // vec2 TBNUV = gl_FrontFacing ? vBumpUV : -vBumpUV;\n        vec2 TBNUV = gl_FrontFacing ? mainUv : -mainUv;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vTangentSpaceParams);\n    #else\n        vec2 TBNUV = gl_FrontFacing ? vDetailUV : -vDetailUV;\n        mat3 TBN = cotangent_frame(normalW * normalScale, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#elif defined(ANISOTROPIC)\n    #if defined(TANGENT) && defined(NORMAL)\n        mat3 TBN = vTBN;\n    #else\n        // flip the uv for the backface\n        vec2 TBNUV = gl_FrontFacing ? vMainUV1 : -vMainUV1;\n        mat3 TBN = cotangent_frame(normalW, vPositionW, TBNUV, vec2(1., 1.));\n    #endif\n#endif\n\n#ifdef PARALLAX\n    mat3 invTBN = transposeMat3(TBN);\n\n    #ifdef PARALLAXOCCLUSION\n        // uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, vBumpUV, vBumpInfos.z);\n        uvOffset = parallaxOcclusion(invTBN * -viewDirectionW, invTBN * normalW, mainUv, vBumpInfos.z);\n    #else\n        uvOffset = parallaxOffset(invTBN * viewDirectionW, vBumpInfos.z);\n    #endif\n#endif\n\n#ifdef DETAIL\n    vec4 detailColor = texture2D(detailSampler, vDetailUV + uvOffset);\n    vec2 detailNormalRG = detailColor.wy * 2.0 - 1.0;\n    float detailNormalB = sqrt(1. - saturate(dot(detailNormalRG, detailNormalRG)));\n    vec3 detailNormal = vec3(detailNormalRG, detailNormalB);\n#endif\n\n#ifdef BUMP\n    #ifdef OBJECTSPACE_NORMALMAP\n        // normalW = normalize(texture2D(bumpSampler, vBumpUV).xyz  * 2.0 - 1.0);\n        normalW = normalize(texture2D(bumpSampler, mainUv).xyz  * 2.0 - 1.0);\n        normalW = normalize(mat3(normalMatrix) * normalW);\n    #elif !defined(DETAIL)\n        // normalW = perturbNormal(TBN, texture2D(bumpSampler, vBumpUV + uvOffset).xyz, vBumpInfos.y);\n        normalW = perturbNormal(TBN, texture2D(bumpSampler, mainUv + uvOffset).xyz, vBumpInfos.y);\n    #else\n        // vec3 bumpNormal = texture2D(bumpSampler, vBumpUV + uvOffset).xyz * 2.0 - 1.0;\n        vec3 bumpNormal = texture2D(bumpSampler, mainUv + uvOffset).xyz * 2.0 - 1.0;\n        // Reference for normal blending: https://blog.selfshadow.com/publications/blending-in-detail/\n        #if DETAIL_NORMALBLENDMETHOD == 0 // whiteout\n            detailNormal.xy *= vDetailInfos.z;\n            vec3 blendedNormal = normalize(vec3(bumpNormal.xy + detailNormal.xy, bumpNormal.z * detailNormal.z));\n        #elif DETAIL_NORMALBLENDMETHOD == 1 // RNM\n            detailNormal.xy *= vDetailInfos.z;\n            bumpNormal += vec3(0.0, 0.0, 1.0);\n            detailNormal *= vec3(-1.0, -1.0, 1.0);\n            vec3 blendedNormal = bumpNormal * dot(bumpNormal, detailNormal) / bumpNormal.z - detailNormal;\n        #endif\n        normalW = perturbNormalBase(TBN, blendedNormal, vBumpInfos.y);\n    #endif\n#elif defined(DETAIL)\n        detailNormal.xy *= vDetailInfos.z;\n        normalW = perturbNormalBase(TBN, detailNormal, vDetailInfos.z);\n#endif\n",m.Effect.ShadersStore.mtoonVertexShader="// it is based on default.vertex.fx\n// This include is special, it will be replaced to UboDeclaration(WebGL2) or VertexDeclaration(WebGL1).\n// @see effect.ts\n#include<__decl__mtoonVertex>\n\n// Attributes\n\n#define CUSTOM_VERTEX_BEGIN\n\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n\n#include<helperFunctions>\n\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n\n// Uniforms\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n// # if defined(SPECULARTERM)\n// # include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n// # endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade)\n#include<samplerVertexDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim)\n#include<samplerVertexDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth)\n#include<samplerVertexDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask)\n\n// Additional Uniforms\n#ifdef OUTLINE_WIDTH\n    uniform sampler2D outlineWidthSampler;\n#endif\n\n// Output\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<bumpVertexDeclaration>\n\n#include<clipPlaneVertexDeclaration>\n\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # endif\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\n\nvoid main(void) {\n\n    #define CUSTOM_VERTEX_MAIN_BEGIN\n\n    vec3 positionUpdated = position;\n#ifdef NORMAL\n    vec3 normalUpdated = normal;\n#endif\n#ifdef TANGENT\n    vec4 tangentUpdated = tangent;\n#endif\n#ifdef UV1\n    vec2 uvUpdated = uv;\n#endif\n\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n\n// # ifdef REFLECTIONMAP_SKYBOX\n//     vPositionUVW = positionUpdated;\n// # endif\n\n#define CUSTOM_VERTEX_UPDATE_POSITION\n\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n\n#include<instancesVertex>\n\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\n    // Compute velocity before bones computation\n    vCurrentPosition = viewProjection * finalWorld * vec4(positionUpdated, 1.0);\n    vPreviousPosition = previousViewProjection * finalPreviousWorld * vec4(positionUpdated, 1.0);\n#endif\n\n#include<bonesVertex>\n#include<bakedVertexAnimation>\n\n    // Texture coordinates\n#ifndef UV1\n    vec2 uvUpdated = vec2(0., 0.);\n#endif\n#ifdef MAINUV1\n    vMainUV1 = uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n\n    float outlineTex = 1.0;\n    if (isOutline == 1.0) {\n#ifdef OUTLINE_WIDTH\n    #if OUTLINE_WIDTHDIRECTUV == 0\n        if (vOutlineWidthInfos.x == 0.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uvUpdated, 1.0, 0.0));\n        }\n        #ifdef UV2\n        else if (vOutlineWidthInfos.x == 1.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv2, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV3\n        else if (vOutlineWidthInfos.x == 2.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv3, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV4\n        else if (vOutlineWidthInfos.x == 3.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv4, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV5\n        else if (vOutlineWidthInfos.x == 4.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv5, 1.0, 0.0));\n        }\n        #endif\n        #ifdef UV6\n        else if (vOutlineWidthInfos.x == 5.)\n        {\n            vOutlineWidthUV = vec2(outlineWidthMatrix * vec4(uv6, 1.0, 0.0));\n        }\n        #endif\n    #elif defined(MAINUV1)\n        vec2 vOutlineWidthUV = vMainUV1;\n    #elif defined(MAINUV2)\n        vec2 vOutlineWidthUV = vMainUV2;\n    #else\n        vec2 vOutlineWidthUV = vec2(0., 0.);\n    #endif\n        outlineTex = texture2D(outlineWidthSampler, vOutlineWidthUV).r * vOutlineWidthInfos.y;\n#endif\n\n#if defined(MTOON_OUTLINE_WIDTH_WORLD) && defined(NORMAL)\n        // move slightly world normal\n        vec3 outlineOffset = 0.01 * outlineWidth * outlineTex * length(transposeMat3(inverseMat3(mat3(finalWorld))) * normalUpdated) * normalUpdated;\n        positionUpdated += outlineOffset;\n#endif\n    } // End isOutline == 1.0\n\n    vec4 worldPos = finalWorld * vec4(positionUpdated, 1.0);\n\n#ifdef NORMAL\n    mat3 normalWorld = mat3(finalWorld);\n\n    #if defined(INSTANCES) && defined(THIN_INSTANCES)\n        vNormalW = normalUpdated / vec3(dot(normalWorld[0], normalWorld[0]), dot(normalWorld[1], normalWorld[1]), dot(normalWorld[2], normalWorld[2]));\n        vNormalW = normalize(normalWorld * vNormalW);\n    #else\n        #ifdef NONUNIFORMSCALING\n            normalWorld = transposeMat3(inverseMat3(normalWorld));\n        #endif\n\n        vNormalW = normalize(normalWorld * normalUpdated);\n    #endif\n#endif\n\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n\n#ifdef MULTIVIEW\n    if (gl_ViewID_OVR == 0u) {\n        gl_Position = viewProjection * worldPos;\n    } else {\n        gl_Position = viewProjectionR * worldPos;\n    }\n#else\n    gl_Position = viewProjection * worldPos;\n#endif\n\n    if (isOutline == 1.0) {\n#if defined(MTOON_OUTLINE_WIDTH_SCREEN) && defined(NORMAL)\n        vec3 viewNormal = transposeMat3(inverseMat3(mat3(view) * mat3(finalWorld))) * normalUpdated;\n        vec3 clipNormal = mat3(projection) * viewNormal;\n        vec2 projectedNormal = normalize(clipNormal.xy);\n        projectedNormal *= min(gl_Position.w, outlineScaledMaxDistance);\n        projectedNormal.x /= aspect; // aspect in original mtoon is y/x. aspect in babylon is x/y.\n        gl_Position.xy += 0.01 * outlineWidth * outlineTex * projectedNormal * clamp(1.0 - abs(normalize(viewNormal).z), 0.0, 1.0); // ignore offset when normal toward camera\n#endif\n\n        gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic from three-vrm\n    }\n\n    worldPos = finalWorld * vec4(positionUpdated, 1.0);\n    vPositionW = vec3(worldPos);\n\n#include<prePassVertex>\n\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n//     vDirectionW = normalize(vec3(finalWorld * vec4(positionUpdated, 0.0)));\n// # endif\n\n    #include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n    // # if defined(SPECULARTERM)\n    // # include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n    // # endif\n    #include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_MATRIXNAME_,shade,_INFONAME_,ShadeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_MATRIXNAME_,receiveShadow,_INFONAME_,ReceiveShadowInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_MATRIXNAME_,shadingGrade,_INFONAME_,ShadingGradeInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_MATRIXNAME_,rim,_INFONAME_,RimInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_MATRIXNAME_,matCap,_INFONAME_,MatCapInfos.x)\n    #include<samplerVertexImplementation>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_MATRIXNAME_,uvAnimationMask,_INFONAME_,uvAnimationMaskInfos.x)\n\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n\n#ifdef VERTEXCOLOR\n    vColor = color;\n#elif defined(INSTANCESCOLOR) && INSTANCESCOLOR\n    vColor = instanceColor;\n#endif\n\n#include<pointCloudVertex>\n#include<logDepthVertex>\n\n#define CUSTOM_VERTEX_MAIN_END\n\n}\n",m.Effect.ShadersStore.mtoonFragmentShader="#include<__decl__mtoonFragment>\n\n#extension GL_OES_standard_derivatives : enable\n\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n\n#define CUSTOM_FRAGMENT_BEGIN\n\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n\n// Constants\n// #define RECIPROCAL_PI2 0.15915494\n#define PI_2 6.28318530718\n#define EPS_COL 0.00001\n\n// Input\nvarying vec3 vPositionW;\n\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR)\nvarying vec4 vColor;\n#endif\n\n#include<mainUVVaryingDeclaration>[1..7]\n\n// Helper functions\n#include<helperFunctions>\n\n// Lights\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n\n// Samplers\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADE,_VARYINGNAME_,Shade,_SAMPLERNAME_,shade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RECEIVE_SHADOW,_VARYINGNAME_,ReceiveShadow,_SAMPLERNAME_,receiveShadow)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SHADING_GRADE,_VARYINGNAME_,ShadingGrade,_SAMPLERNAME_,shadingGrade)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,RIM,_VARYINGNAME_,Rim,_SAMPLERNAME_,rim)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,MATCAP,_VARYINGNAME_,MatCap,_SAMPLERNAME_,matCap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OUTLINE_WIDTH,_VARYINGNAME_,OutlineWidth,_SAMPLERNAME_,outlineWidth)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,UV_ANIMATION_MASK,_VARYINGNAME_,UvAnimationMask,_SAMPLERNAME_,uvAnimationMask)\n\n#include<mtoonFragmentFunctions>\n\n// # ifdef REFRACTION\n\n// # ifdef REFRACTIONMAP_3D\n// uniform samplerCube refractionCubeSampler;\n// # else\n// uniform sampler2D refraction2DSampler;\n// # endif\n\n// # endif\n\n// # if defined(SPECULARTERM)\n//     # include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n// # endif\n\n// // Fresnel\n// # include<fresnelFunction>\n\n// // Reflection\n// # ifdef REFLECTION\n// # ifdef REFLECTIONMAP_3D\n// uniform samplerCube reflectionCubeSampler;\n// # else\n// uniform sampler2D reflection2DSampler;\n// # endif\n\n// # ifdef REFLECTIONMAP_SKYBOX\n// varying vec3 vPositionUVW;\n// # else\n// # if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\n// varying vec3 vDirectionW;\n// # endif\n\n// # endif\n\n// # include<reflectionFunction>\n\n// # endif\n\n#include<imageProcessingDeclaration>\n\n#include<imageProcessingFunctions>\n\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n\n#define CUSTOM_FRAGMENT_DEFINITIONS\n\nvoid main(void) {\n#ifdef MTOON_CLIP_IF_OUTLINE_IS_NONE\n    #ifdef MTOON_OUTLINE_WIDTH_WORLD\n    #elif defined(MTOON_OUTLINE_WIDTH_SCREEN)\n    #else\n        discard;\n    #endif\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n\n#include<oitFragment>\n\n#include<clipPlaneFragment>\n\n    vec3 viewDirectionW = normalize(vEyePosition.xyz - vPositionW);\n\n    // Base color\n    vec4 baseColor = vec4(1., 1., 1., 1.);\n    vec3 diffuseColor = vec3(1., 1., 1.);\n\n    // Alpha\n    float alpha = 1.0;\n\n    // Bump\n#ifdef NORMAL\n    vec3 normalW = normalize(vNormalW);\n#else\n    vec3 normalW = normalize(-cross(dFdx(vPositionW), dFdy(vPositionW)));\n#endif\n\n#include<depthPrePass>\n\n    // Ambient color\n    vec3 baseAmbientColor = vec3(1., 1., 1.);\n    float glossiness = 0.;\n\n    // Lighting\n    vec3 diffuseBase = vec3(0., 0., 0.);\n    lightingInfo info;\n    float shadow = 1.;\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\n    vec4 mtoonDiffuse = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // MToon UV\n    // All textures will use diffuse(_MainTex) UV\n    vec2 mainUv = vec2(0.0);\n#ifdef DIFFUSE\n    mainUv += vDiffuseUV;\n#elif defined(MAINUV1)\n    mainUv += vMainUV1;\n#elif defined(MAINUV2)\n    mainUv += vMainUV2;\n#endif\n\n    // uv anim\n    float uvAnim = time.y;\n#ifdef UV_ANIMATION_MASK\n    uvAnim *= texture2D(uvAnimationMaskSampler, mainUv).r;\n#endif\n    // translate uv in bottom-left origin coordinates.\n    // uv is reversed\n    mainUv += vec2(-uvAnimationScrollX, -uvAnimationScrollY) * uvAnim;\n    // rotate uv counter-clockwise around (0.5, 0.5) in bottom-left origin coordinates.\n    float rotateRad = uvAnimationRotation * PI_2 * uvAnim;\n    vec2 rotatePivot = vec2(0.5, 0.5);\n    mainUv = mat2(cos(rotateRad), -sin(rotateRad), sin(rotateRad), cos(rotateRad)) * (mainUv - rotatePivot) + rotatePivot;\n\n#ifdef FLIP_U\n    mainUv.x = 1.0 - mainUv.x;\n#endif\n#ifdef FLIP_V\n    mainUv.y = 1.0 - mainUv.y;\n#endif\n\n#include<mtoonBumpFragment>\n\n#ifdef TWOSIDEDLIGHTING\n    normalW = gl_FrontFacing ? normalW : -normalW;\n#endif\n\n// include customized lightFragment\n#include<mtoonLightFragment>[0..maxSimultaneousLights]\n\n    vec3 finalDiffuse = clamp(diffuseBase, 0.0, 1.0) * baseColor.rgb;\n\n    // Composition\n    vec4 color = vec4(finalDiffuse, clamp(alpha, 0.0, 1.0));\n\n    color.rgb = max(color.rgb, 0.);\n#include<logDepthFragment>\n#include<fogFragment>\n\n// Apply image processing if relevant. As this applies in linear space,\n// We first move from gamma to linear.\n#ifdef IMAGEPROCESSINGPOSTPROCESS\n    color.rgb = toLinearSpace(color.rgb);\n#else\n    #ifdef IMAGEPROCESSING\n        // FIXME: support image processing\n        // color.rgb = toLinearSpace(color.rgb);\n        // color = applyImageProcessing(color);\n    #endif\n#endif\n\n    color.a *= visibility;\n\n#ifdef PREMULTIPLYALPHA\n    // Convert to associative (premultiplied) format if needed.\n    color.rgb *= color.a;\n#endif\n\n#ifdef PREPASS\n    float writeGeometryInfo = color.a > 0.4 ? 1.0 : 0.0;\n\n    gl_FragData[0] = color; // We can't split irradiance on std material\n\n    #ifdef PREPASS_POSITION\n    gl_FragData[PREPASS_POSITION_INDEX] = vec4(vPositionW, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_VELOCITY\n    vec2 a = (vCurrentPosition.xy / vCurrentPosition.w) * 0.5 + 0.5;\n    vec2 b = (vPreviousPosition.xy / vPreviousPosition.w) * 0.5 + 0.5;\n\n    vec2 velocity = abs(a - b);\n    velocity = vec2(pow(velocity.x, 1.0 / 3.0), pow(velocity.y, 1.0 / 3.0)) * sign(a - b) * 0.5 + 0.5;\n\n    gl_FragData[PREPASS_VELOCITY_INDEX] = vec4(velocity, 0.0, writeGeometryInfo);\n    #endif\n\n    #ifdef PREPASS_IRRADIANCE\n        gl_FragData[PREPASS_IRRADIANCE_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); //  We can't split irradiance on std material\n    #endif\n\n    #ifdef PREPASS_DEPTH\n        gl_FragData[PREPASS_DEPTH_INDEX] = vec4(vViewPos.z, 0.0, 0.0, writeGeometryInfo); // Linear depth\n    #endif\n\n    #ifdef PREPASS_NORMAL\n        gl_FragData[PREPASS_NORMAL_INDEX] = vec4((view * vec4(normalW, 0.0)).rgb, writeGeometryInfo); // Normal\n    #endif\n\n    #ifdef PREPASS_ALBEDO_SQRT\n        gl_FragData[PREPASS_ALBEDO_SQRT_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo); // We can't split albedo on std material\n    #endif\n    #ifdef PREPASS_REFLECTIVITY\n        #if defined(SPECULAR)\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(specularMapColor.rgb, specularMapColor.a * writeGeometryInfo);\n        #else\n            gl_FragData[PREPASS_REFLECTIVITY_INDEX] = vec4(0.0, 0.0, 0.0, writeGeometryInfo);\n        #endif\n    #endif\n#endif\n\n#if !defined(PREPASS) || defined(WEBGL2)\n    gl_FragColor = color;\n#endif\n\n#if ORDER_INDEPENDENT_TRANSPARENCY\n    if (fragDepth == nearestDepth) {\n        frontColor.rgb += color.rgb * color.a * alphaMultiplier;\n        frontColor.a = 1.0 - alphaMultiplier * (1.0 - color.a);\n    } else {\n        backColor += color;\n    }\n#endif\n\n#define CUSTOM_FRAGMENT_MAIN_END\n\n}\n"),this.inspectableCustomProperties=this.inspectableCustomProperties||[],this.inspectableCustomProperties.push({label:"DiffuseColor",propertyName:"diffuseColor",type:M.InspectableType.Color3},{label:"AmbientColor",propertyName:"ambientColor",type:M.InspectableType.Color3},{label:"EmissiveColor",propertyName:"emissiveColor",type:M.InspectableType.Color3},{label:"ShadeColor",propertyName:"shadeColor",type:M.InspectableType.Color3},{label:"RimColor",propertyName:"rimColor",type:M.InspectableType.Color3},{label:"OutlineColor",propertyName:"outlineColor",type:M.InspectableType.Color3},{label:"ReceiveShadowRate",propertyName:"receiveShadowRate",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadingGradeRate",propertyName:"shadingGradeRate",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"ShadeShift",propertyName:"shadeShift",type:M.InspectableType.Slider,min:-1,max:1,step:.01},{label:"ShadeToony",propertyName:"shadeToony",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"LightColorAttenuation",propertyName:"lightColorAttenuation",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"IndirectLightIntensity",propertyName:"indirectLightIntensity",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimLightingMix",propertyName:"rimLightingMix",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"RimFresnelPower",propertyName:"rimFresnelPower",type:M.InspectableType.Slider,min:.01,max:100,step:4},{label:"RimLift",propertyName:"rimLift",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"OutlineWidth",propertyName:"outlineWidth",type:M.InspectableType.Slider,min:.01,max:1,step:.01},{label:"OutlineScaledMaxDistance",propertyName:"outlineScaledMaxDistance",type:M.InspectableType.Slider,min:1,max:10,step:.01},{label:"OutlineLightingMix",propertyName:"outlineLightingMix",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"DebugMode",propertyName:"debugMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineWidthMode",propertyName:"outlineWidthMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineColorMode",propertyName:"outlineColorMode",type:M.InspectableType.Slider,min:0,max:1,step:1},{label:"CullMode",propertyName:"cullMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"OutlineCullMode",propertyName:"outlineCullMode",type:M.InspectableType.Slider,min:0,max:2,step:1},{label:"AlphaCutOff",propertyName:"alphaCutOff",type:M.InspectableType.Slider,min:0,max:1,step:.01},{label:"UV Animation Scroll X",propertyName:"uvAnimationScrollX",type:M.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Scroll Y",propertyName:"uvAnimationScrollY",type:M.InspectableType.Slider,min:-1,max:1,step:.1},{label:"UV Animation Rotation",propertyName:"uvAnimationRotation",type:M.InspectableType.Slider,min:-.5,max:.5,step:.01})}get appendedTextures(){return[this._diffuseTexture,this._emissiveTexture,this._bumpTexture,this._shadeTexture,this._receiveShadowTexture,this._shadingGradeTexture,this._rimTexture,this._matCapTexture,this._outlineWidthTexture,this._uvAnimationMaskTexture]}get appendedActiveTextures(){return this.appendedTextures.filter((e=>null!==e))}get imageProcessingConfiguration(){return this._imageProcessingConfiguration}set imageProcessingConfiguration(e){this._attachImageProcessingConfiguration(e),this._markAllSubMeshesAsTexturesDirty()}_attachImageProcessingConfiguration(e){e!==this._imageProcessingConfiguration&&(this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),this._imageProcessingConfiguration=e||this.getScene().imageProcessingConfiguration,this._imageProcessingConfiguration&&(this._imageProcessingObserver=this._imageProcessingConfiguration.onUpdateParameters.add((()=>{this._markAllSubMeshesAsImageProcessingDirty()}))))}get isPrePassCapable(){return!1}get cameraColorCurvesEnabled(){return this.imageProcessingConfiguration.colorCurvesEnabled}set cameraColorCurvesEnabled(e){this.imageProcessingConfiguration.colorCurvesEnabled=e}get cameraColorGradingEnabled(){return this.imageProcessingConfiguration.colorGradingEnabled}set cameraColorGradingEnabled(e){this.imageProcessingConfiguration.colorGradingEnabled=e}get cameraToneMappingEnabled(){return this._imageProcessingConfiguration.toneMappingEnabled}set cameraToneMappingEnabled(e){this._imageProcessingConfiguration.toneMappingEnabled=e}get cameraExposure(){return this._imageProcessingConfiguration.exposure}set cameraExposure(e){this._imageProcessingConfiguration.exposure=e}get cameraContrast(){return this._imageProcessingConfiguration.contrast}set cameraContrast(e){this._imageProcessingConfiguration.contrast=e}get cameraColorGradingTexture(){return this._imageProcessingConfiguration.colorGradingTexture}set cameraColorGradingTexture(e){this._imageProcessingConfiguration.colorGradingTexture=e}get cameraColorCurves(){return this._imageProcessingConfiguration.colorCurves}set cameraColorCurves(e){this._imageProcessingConfiguration.colorCurves=e}get canRenderToMRT(){return!0}get bumpScale(){return this._bumpScale}set bumpScale(e){this._bumpScale=e}get receiveShadowRate(){return this._receiveShadowRate}set receiveShadowRate(e){this._receiveShadowRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadingGradeRate(){return this._shadingGradeRate}set shadingGradeRate(e){this._shadingGradeRate=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeShift(){return this._shadeShift}set shadeShift(e){this._shadeShift=Math.max(-1,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get shadeToony(){return this._shadeToony}set shadeToony(e){this._shadeToony=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get lightColorAttenuation(){return this._lightColorAttenuation}set lightColorAttenuation(e){this._lightColorAttenuation=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get indirectLightIntensity(){return this._indirectLightIntensity}set indirectLightIntensity(e){this._indirectLightIntensity=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimLightingMix(){return this._rimLightingMix}set rimLightingMix(e){this._rimLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get rimFresnelPower(){return this._rimFresnelPower}set rimFresnelPower(e){this._rimFresnelPower=Math.max(0,Math.min(100,e)),this._markAllSubMeshesAsLightsDirty()}get rimLift(){return this._rimLift}set rimLift(e){this._rimLift=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsLightsDirty()}get outlineWidth(){return this._outlineWidth}set outlineWidth(e){this._outlineWidth=Math.max(.01,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineScaledMaxDistance(){return this._outlineScaledMaxDistance}set outlineScaledMaxDistance(e){this._outlineScaledMaxDistance=Math.max(1,Math.min(10,e)),this._markAllSubMeshesAsAttributesDirty()}get outlineLightingMix(){return this._outlineLightingMix}set outlineLightingMix(e){this._outlineLightingMix=Math.max(0,Math.min(1,e)),this._markAllSubMeshesAsAttributesDirty()}get uvAnimationScrollX(){return this._uvAnimationScrollX}set uvAnimationScrollX(e){this._uvAnimationScrollX=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationScrollY(){return this._uvAnimationScrollY}set uvAnimationScrollY(e){this._uvAnimationScrollY=e,this._markAllSubMeshesAsMiscDirty()}get uvAnimationRotation(){return this._uvAnimationRotation}set uvAnimationRotation(e){this._uvAnimationRotation=e,this._markAllSubMeshesAsMiscDirty()}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest=e,e?this.alphaBlend?this._transparencyMode=h.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=h.Material.MATERIAL_ALPHATEST:this.alphaBlend?this._transparencyMode=h.Material.MATERIAL_ALPHABLEND:this._transparencyMode=h.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get alphaBlend(){return this._alphaBlend}set alphaBlend(e){this._alphaBlend=e,e?(this.backFaceCulling=!0,this.alphaTest?this._transparencyMode=h.Material.MATERIAL_ALPHATESTANDBLEND:this._transparencyMode=h.Material.MATERIAL_ALPHABLEND):this.alphaTest?this._transparencyMode=h.Material.MATERIAL_ALPHATEST:this._transparencyMode=h.Material.MATERIAL_OPAQUE,this._markAllSubMeshesAsMiscDirty()}get outlineWidthMode(){return this._outlineWidthMode}set outlineWidthMode(e){this._outlineWidthMode=e,e===P.None||this.outlineRenderer||(this.outlineRenderer=new T(this.getScene(),this)),this._markAllSubMeshesAsMiscDirty()}enableOutlineRender(){this.isOutline=1}disaableOutlineRender(){this.isOutline=0}get cullMode(){return this._cullMode}set cullMode(e){switch(this._cullMode=e,this._cullMode){case C.Off:this.backFaceCulling=!1,this.sideOrientation=h.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1;break;case C.Front:this.backFaceCulling=!0,this.sideOrientation=h.Material.CounterClockWiseSideOrientation,this.twoSidedLighting=!0;break;case C.Back:this.backFaceCulling=!0,this.sideOrientation=h.Material.ClockWiseSideOrientation,this.twoSidedLighting=!1}this._markAllSubMeshesAsMiscDirty()}applyOutlineCullMode(){this.storedCullMode=this.cullMode,this.cullMode=this._outlineCullMode}restoreOutlineCullMode(){this.cullMode=this.storedCullMode}getOutlineRendererName(){return this.outlineRenderer?this.outlineRenderer.name:""}get hasRenderTargetTextures(){return!1}getClassName(){return"MToonMaterial"}get useLogarithmicDepth(){return this._useLogarithmicDepth}set useLogarithmicDepth(e){const t=e&&this.getScene().getEngine().getCaps().fragmentDepthSupported;this._useLogarithmicDepth!==t&&(this._useLogarithmicDepth=t,this._markAllSubMeshesAsMiscDirty())}needAlphaBlending(){return!this._disableAlphaBlending&&(this.alpha<1||this._shouldUseAlphaFromDiffuseTexture())}_shouldUseAlphaFromDiffuseTexture(){return null!=this._diffuseTexture&&this._diffuseTexture.hasAlpha&&this._useAlphaFromDiffuseTexture&&this._transparencyMode!==h.Material.MATERIAL_OPAQUE}_hasAlphaChannel(){return null!==this._diffuseTexture&&this._diffuseTexture.hasAlpha}getAlphaTestTexture(){return this._diffuseTexture}isReadyForSubMesh(e,t,i=!1){this._uniformBufferLayoutBuilt||this.buildUniformLayout();const n=t._drawWrapper;if(n.effect&&this.isFrozen&&n._wasPreviouslyReady&&n._wasPreviouslyUsingInstances===i)return!0;t.materialDefines||(this._callbackPluginEventGeneric(g.MaterialPluginEvent.GetDefineNames,this._eventInfo),t.materialDefines=new S);const r=this.getScene(),o=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const a=r.getEngine();o._needNormals=f.MaterialHelper.PrepareDefinesForLights(r,e,o,this.specularSupported,this._maxSimultaneousLights,this._disableLighting),this.outlineWidthMode!==P.None&&(o._needNormals=!0),this.applyDefines(o),f.MaterialHelper.PrepareDefinesForMultiview(r,o);const h=this.needAlphaBlendingForMesh(e)&&r.useOrderIndependentTransparency;if(f.MaterialHelper.PrepareDefinesForOIT(r,o,h),o._areTexturesDirty){this._eventInfo.hasRenderTargetTextures=!1,this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),this._cacheHasRenderTargetTextures=this._eventInfo.hasRenderTargetTextures,o._needUVs=!1;for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)o["MAINUV"+e]=!1;if(r.texturesEnabled){if(!(this.isReadyForTexture(this._diffuseTexture,o,"DIFFUSE")&&this.isReadyForTexture(this._emissiveTexture,o,"EMISSIVE")&&this.isReadyForTexture(this._shadeTexture,o,"SHADE")&&this.isReadyForTexture(this._receiveShadowTexture,o,"RECEIVE_SHADOW")&&this.isReadyForTexture(this._shadingGradeTexture,o,"SHADING_GRADE")&&this.isReadyForTexture(this._rimTexture,o,"RIM")&&this.isReadyForTexture(this._matCapTexture,o,"MATCAP")&&this.isReadyForTexture(this._outlineWidthTexture,o,"OUTLINE_WIDTH")&&this.isReadyForTexture(this._uvAnimationMaskTexture,o,"UV_ANIMATION_MASK")))return!1;if(r.getEngine().getCaps().standardDerivatives&&this._bumpTexture){if(!this._bumpTexture.isReady())return!1;f.MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture,o,"BUMP"),o.PARALLAX=this.useParallax,o.PARALLAXOCCLUSION=this.useParallaxOcclusion,o.OBJECTSPACE_NORMALMAP=this.useObjectSpaceNormalMap}else o.BUMP=!1,o.PARALLAX=!1,o.PARALLAXOCCLUSION=!1;o.TWOSIDEDLIGHTING=!this._backFaceCulling&&this._twoSidedLighting}else o.DIFFUSE=!1,o.EMISSIVE=!1,o.SHADE=!1,o.RECEIVE_SHADOW=!1,o.SHADING_GRADE=!1,o.RIM=!1,o.MATCAP=!1,o.OUTLINE_WIDTH=!1,o.BUMP=!1,o.UV_ANIMATION_MASK=!1;o.ALPHAFROMDIFFUSE=this._shouldUseAlphaFromDiffuseTexture(),o.PREMULTIPLYALPHA=this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED||this.alphaMode===u.Constants.ALPHA_PREMULTIPLIED_PORTERDUFF,o.ALPHATEST_AFTERALLALPHACOMPUTATIONS=null!==this.transparencyMode,o.ALPHABLEND=null===this.transparencyMode||this.needAlphaBlendingForMesh(e)}if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=o,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(o._areImageProcessingDirty&&this._imageProcessingConfiguration){if(!this._imageProcessingConfiguration.isReady())return!1;this._imageProcessingConfiguration.prepareDefines(o)}this.flipU!==o.FLIP_U&&(o.FLIP_U=this.flipU,o.markAsUnprocessed()),this.flipV!==o.FLIP_V&&(o.FLIP_V=this.flipV,o.markAsUnprocessed()),f.MaterialHelper.PrepareDefinesForMisc(e,r,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,this.needAlphaTestingForMesh(e),o);const d=t.getMaterial();if(d){let e=a;f.MaterialHelper.PrepareDefinesForFrameBoundValues(r,e,d,o,i,null,t.getRenderingMesh().hasThinInstances)}if(this._eventInfo.defines=o,this._eventInfo.mesh=e,this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),f.MaterialHelper.PrepareDefinesForAttributes(e,o,this.useVertexColor,this.useBones,this.useMorphTargets,this.useVertexAlpha,this.useBakedVertexAnimation),this._callbackPluginEventPrepareDefines(this._eventInfo),o.isDirty){const i=o._areLightsDisposed;o.markAsProcessed();const n=new c.EffectFallbacks;o.BUMP&&n.addFallback(0,"BUMP"),o.PARALLAX&&n.addFallback(1,"PARALLAX"),o.PARALLAXOCCLUSION&&n.addFallback(0,"PARALLAXOCCLUSION"),o.FOG&&n.addFallback(1,"FOG"),o.POINTSIZE&&n.addFallback(0,"POINTSIZE"),o.LOGARITHMICDEPTH&&n.addFallback(0,"LOGARITHMICDEPTH"),f.MaterialHelper.HandleFallbacksForShadows(o,n,this._maxSimultaneousLights),o.MULTIVIEW&&n.addFallback(0,"MULTIVIEW");const h=[s.VertexBuffer.PositionKind];o.NORMAL&&h.push(s.VertexBuffer.NormalKind),o.TANGENT&&h.push(s.VertexBuffer.TangentKind);for(let e=1;e<=u.Constants.MAX_SUPPORTED_UV_SETS;++e)o["UV"+e]&&h.push(`uv${1===e?"":e}`);o.INSTANCESCOLOR&&h.push(s.VertexBuffer.ColorInstanceKind),f.MaterialHelper.PrepareAttributesForBones(h,e,o,n),f.MaterialHelper.PrepareAttributesForInstances(h,o),f.MaterialHelper.PrepareAttributesForMorphTargets(h,e,o),f.MaterialHelper.PrepareAttributesForBakedVertexAnimation(h,e,o);const d="mtoon",m=["world","view","viewProjection","vEyePosition","vLightsType","vAmbientColor","visibility","vFogInfos","vFogColor","pointSize","mBones","vClipPlane","vClipPlane2","vClipPlane3","vClipPlane4","vClipPlane5","vClipPlane6","logarithmicDepthConstant","vTangentSpaceParams","alphaCutOff","boneTextureWidth","morphTargetTextureInfo","morphTargetTextureIndices","vDiffuseColor","vDiffuseInfos","diffuseMatrix","vEmissiveColor","vEmissiveInfos","emissiveMatrix","vBumpInfos","bumpMatrix","vShadeColor","vShadeInfos","shadeMatrix","vReceiveShadowInfos","receiveShadowMatrix","vShadingGradeInfos","shadingGradeMatrix","vRimColor","vRimInfos","RimMatrix","vMatCapInfos","MatCapMatrix","vOutlineColor","vOutlineWidthInfos","outlineWidthMatrix","aspect","isOutline","shadingGradeRate","receiveShadowRate","shadeShift","shadeToony","rimLightingMix","rimFresnelPower","rimLift","lightColorAttenuation","indirectLightIntensity","outlineWidth","outlineScaledMaxDistance","outlineLightingMix","uvAnimationScrollX","uvAnimationScrollY","uvAnimationRotation","vEyeUp","time","projection"],p=["diffuseSampler","ambientSampler","emissiveSampler","bumpSampler","boneSampler","morphTargets","oitDepthSampler","oitFrontColorSampler","shadeSampler","receiveShadowSampler","shadingGradeSampler","rimSampler","matCapSampler","outlineWidthSampler","uvAnimationMaskSampler"],M=["Material","Scene","Mesh"];this._eventInfo.fallbacks=n,this._eventInfo.fallbackRank=0,this._eventInfo.defines=o,this._eventInfo.uniforms=m,this._eventInfo.attributes=h,this._eventInfo.samplers=p,this._eventInfo.uniformBuffersNames=M,this._eventInfo.customCode=void 0,this._eventInfo.mesh=e,this._callbackPluginEventGeneric(g.MaterialPluginEvent.PrepareEffect,this._eventInfo),l.ImageProcessingConfiguration&&(l.ImageProcessingConfiguration.PrepareUniforms(m,o),l.ImageProcessingConfiguration.PrepareSamplers(p,o)),f.MaterialHelper.PrepareUniformsAndSamplersList({uniformsNames:m,uniformBuffersNames:M,samplers:p,defines:o,maxSimultaneousLights:this._maxSimultaneousLights});const _={},T=o.toString(),v=t.effect;let I=r.getEngine().createEffect(d,{attributes:h,uniformsNames:m,uniformBuffersNames:M,samplers:p,defines:T,fallbacks:n,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousLights:this._maxSimultaneousLights,maxSimultaneousMorphTargets:o.NUM_MORPH_INFLUENCERS},processFinalCode:_.processFinalCode,processCodeAfterIncludes:this._eventInfo.customCode,multiTarget:o.PREPASS},a);if(I)if(this._onEffectCreatedObservable&&(E.effect=I,E.subMesh=t,this._onEffectCreatedObservable.notifyObservers(E)),this.allowShaderHotSwapping&&v&&!I.isReady()){if(I=v,o.markAsUnprocessed(),i)return o._areLightsDisposed=!0,!1}else r.resetCachedMaterial(),t.setEffect(I,o,this._materialContext)}return!(!t.effect||!t.effect.isReady()||(o._renderId=r.getRenderId(),n._wasPreviouslyReady=!0,n._wasPreviouslyUsingInstances=i,0))}buildUniformLayout(){const e=this._uniformBuffer;e.addUniform("vDiffuseColor",4),e.addUniform("vDiffuseInfos",2),e.addUniform("diffuseMatrix",16),e.addUniform("vEmissiveColor",3),e.addUniform("vEmissiveInfos",2),e.addUniform("emissiveMatrix",16),e.addUniform("vBumpInfos",3),e.addUniform("bumpMatrix",16),e.addUniform("vShadeColor",3),e.addUniform("vShadeInfos",2),e.addUniform("shadeMatrix",16),e.addUniform("vReceiveShadowInfos",2),e.addUniform("receiveShadowMatrix",16),e.addUniform("vShadingGradeInfos",2),e.addUniform("shadingGradeMatrix",16),e.addUniform("vRimColor",3),e.addUniform("vRimInfos",2),e.addUniform("rimMatrix",16),e.addUniform("vMatCapInfos",2),e.addUniform("matCapMatrix",16),e.addUniform("vOutlineColor",3),e.addUniform("vOutlineWidthInfos",2),e.addUniform("outlineWidthMatrix",16),e.addUniform("vUvAnimationMaskInfos",2),e.addUniform("uvAnimationMaskMatrix",16),e.addUniform("vTangentSpaceParams",2),e.addUniform("pointSize",1),e.addUniform("shadingGradeRate",1),e.addUniform("receiveShadowRate",1),e.addUniform("shadeShift",1),e.addUniform("shadeToony",1),e.addUniform("lightColorAttenuation",1),e.addUniform("indirectLightIntensity",1),e.addUniform("rimLightingMix",1),e.addUniform("rimFresnelPower",1),e.addUniform("rimLift",1),e.addUniform("outlineWidth",1),e.addUniform("outlineScaledMaxDistance",1),e.addUniform("outlineLightingMix",1),e.addUniform("uvAnimationScrollX",1),e.addUniform("uvAnimationScrollY",1),e.addUniform("uvAnimationRotation",1),e.addUniform("vEyeUp",3),e.addUniform("alphaCutOff",1),e.addUniform("vAmbientColor",3),e.addUniform("aspect",1),e.addUniform("isOutline",1),e.addUniform("time",4),e.addUniform("visibility",1),super.buildUniformLayout()}bindForSubMesh(e,t,i){var n;const a=this.getScene(),s=i.materialDefines,l=i.effect;if(!s||!l)return;this._activeEffect=l,t.getMeshUniformBuffer().bindToEffect(l,"Mesh"),t.transferToEffect(e),this._uniformBuffer.bindToEffect(l,"Material"),this._eventInfo.subMesh=i,this._callbackPluginEventHardBindForSubMesh(this._eventInfo),s.OBJECTSPACE_NORMALMAP&&(e.toNormalMatrix(this._normalMatrix),this.bindOnlyNormalMatrix(this._normalMatrix));const h=this._mustRebind(a,l,i,t.visibility);f.MaterialHelper.BindBonesParameters(t,l);const d=this._uniformBuffer;if(h){this.bindViewProjection(l),d.useUbo&&this.isFrozen&&d.isSync||(a.texturesEnabled&&(this.bindTexture(this._diffuseTexture,d,l,"diffuse","vDiffuseInfos"),this.bindTexture(this._emissiveTexture,d,l,"emissive","vEmissiveInfos"),this._bumpTexture&&a.getEngine().getCaps().standardDerivatives&&(d.updateFloat3("vBumpInfos",this._bumpTexture.coordinatesIndex,1/this._bumpTexture.level,this._bumpScale),f.MaterialHelper.BindTextureMatrix(this._bumpTexture,d,"bump"),l.setTexture("bumpSampler",this._bumpTexture),a._mirroredCameraPosition?d.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?1:-1,this._invertNormalMapY?1:-1):d.updateFloat2("vTangentSpaceParams",this._invertNormalMapX?-1:1,this._invertNormalMapY?-1:1)),this.bindTexture(this._shadeTexture,d,l,"shade","vShadeInfos"),this.bindTexture(this._receiveShadowTexture,d,l,"receiveShadow","vReceiveShadowInfos"),this.bindTexture(this._shadingGradeTexture,d,l,"shadingGrade","vShadingGradeInfos"),this.bindTexture(this._rimTexture,d,l,"rim","vRimInfos"),this.bindTexture(this._matCapTexture,d,l,"matCap","vMatCapInfos"),this.bindTexture(this._outlineWidthTexture,d,l,"outlineWidth","vOutlineWidthInfos"),this.bindTexture(this._uvAnimationMaskTexture,d,l,"uvAnimationMask","vUvAnimationMaskInfos"),this._hasAlphaChannel()&&d.updateFloat("alphaCutOff",this.alphaCutOff)),this.pointsCloud&&d.updateFloat("pointSize",this.pointSize),d.updateFloat("receiveShadowRate",this._receiveShadowRate),d.updateFloat("shadingGradeRate",this._shadingGradeRate),d.updateFloat("shadeShift",this._shadeShift),d.updateFloat("shadeToony",this._shadeToony),d.updateFloat("lightColorAttenuation",this._lightColorAttenuation),d.updateFloat("indirectLightIntensity",this._indirectLightIntensity),d.updateFloat("rimLightingMix",this._rimLightingMix),d.updateFloat("rimFresnelPower",this._rimFresnelPower),d.updateFloat("rimLift",this._rimLift),d.updateFloat("outlineWidth",this._outlineWidth),d.updateFloat("outlineScaledMaxDistance",this._outlineScaledMaxDistance),d.updateFloat("outlineLightingMix",this._outlineLightingMix),d.updateFloat("uvAnimationScrollX",this._uvAnimationScrollX),d.updateFloat("uvAnimationScrollY",this._uvAnimationScrollY),d.updateFloat("uvAnimationRotation",this._uvAnimationRotation),a.ambientColor.multiplyToRef(this.ambientColor,this._globalAmbientColor),d.updateColor3("vAmbientColor",this._globalAmbientColor),d.updateColor4("vDiffuseColor",this.diffuseColor,this.alpha),d.updateColor3("vEmissiveColor",this.emissiveColor),d.updateColor3("vShadeColor",this.shadeColor),d.updateColor3("vRimColor",this.rimColor),d.updateColor4("vOutlineColor",this.outlineColor,1),d.updateVector3("vEyeUp",a.activeCamera.upVector));const e=a;e.useOrderIndependentTransparency&&this.needAlphaBlendingForMesh(t)&&e.depthPeelingRenderer&&e.depthPeelingRenderer.bind(l),this._eventInfo.subMesh=i,this._callbackPluginEventBindForSubMesh(this._eventInfo),class{static BindClipPlane(e,t){if(t.clipPlane){const i=t.clipPlane;e.setFloat4("vClipPlane",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane2){const i=t.clipPlane2;e.setFloat4("vClipPlane2",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane3){const i=t.clipPlane3;e.setFloat4("vClipPlane3",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane4){const i=t.clipPlane4;e.setFloat4("vClipPlane4",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane5){const i=t.clipPlane5;e.setFloat4("vClipPlane5",i.normal.x,i.normal.y,i.normal.z,i.d)}if(t.clipPlane6){const i=t.clipPlane6;e.setFloat4("vClipPlane6",i.normal.x,i.normal.y,i.normal.z,i.d)}}}.BindClipPlane(l,a),a.clipPlane=null,this.bindEyePosition(l)}else a.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0);if(h||!this.isFrozen){a.lightsEnabled&&!this._disableLighting&&f.MaterialHelper.BindLights(a,t,l,s,this._maxSimultaneousLights),(a.fogEnabled&&t.applyFog&&a.fogMode!==r.Scene.FOGMODE_NONE||t.receiveShadows)&&this.bindView(l),f.MaterialHelper.BindFogParameters(a,t,l),s.NUM_MORPH_INFLUENCERS&&f.MaterialHelper.BindMorphTargetParameters(t,l),s.BAKED_VERTEX_ANIMATION_TEXTURE&&(null===(n=t.bakedVertexAnimationManager)||void 0===n||n.bind(l,s.INSTANCES)),this.useLogarithmicDepth&&f.MaterialHelper.BindLogDepth(s,l,a),this._imageProcessingConfiguration&&!this._imageProcessingConfiguration.applyByPostProcess&&this._imageProcessingConfiguration.bind(this._activeEffect),d.updateFloat("aspect",a.getEngine().getAspectRatio(a.activeCamera)),d.updateFloat("isOutline",this.isOutline);const e=window.performance.now()/1e3;d.updateVector4("time",new o.Vector4(e/20,e,2*e,3*e))}this._afterBind(t,this._activeEffect),d.update()}getAnimatables(){const e=super.getAnimatables();for(const t of this.appendedActiveTextures)t.animations&&t.animations.length>0&&e.push(t);return e}getActiveTextures(){return super.getActiveTextures().concat(this.appendedActiveTextures)}hasTexture(e){if(super.hasTexture(e))return!0;for(const t of this.appendedActiveTextures)if(t===e)return!0;return!1}dispose(e,t){if(delete this.outlineRenderer,t)for(const e of this.appendedActiveTextures)e.dispose();this._imageProcessingConfiguration&&this._imageProcessingObserver&&this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),super.dispose(e,t)}clone(e){const t=i.SerializationHelper.Clone((()=>new L(e,this.getScene())),this);return t.name=e,t.id=e,this.stencil.copyTo(t.stencil),t}static Parse(e,t,n){const r=i.SerializationHelper.Parse((()=>new L(e.name,t)),e,t,n);return e.stencil&&r.stencil.parse(e.stencil,t,n),r}bindTexture(e,t,i,n,r){e&&(this._uniformBuffer.updateFloat2(r,e.coordinatesIndex,e.level),f.MaterialHelper.BindTextureMatrix(e,t,n),i.setTexture(`${n}Sampler`,e))}isReadyForTexture(e,t,i){return e?!!e.isReadyOrNotBlocking()&&(f.MaterialHelper.PrepareDefinesForMergedUV(e,t,i),!0):(t[i]=!1,!0)}applyDefines(e){switch(this._debugMode){case x.Normal:!0!==e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!0,e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed());break;case x.LitShadeRate:!0!==e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_NORMAL=!1,e.MTOON_DEBUG_LITSHADERATE=!0,e.markAsUnprocessed());break;case x.None:!0===e.MTOON_DEBUG_NORMAL&&(e.MTOON_DEBUG_NORMAL=!1,e.markAsUnprocessed()),!0===e.MTOON_DEBUG_LITSHADERATE&&(e.MTOON_DEBUG_LITSHADERATE=!1,e.markAsUnprocessed())}switch(this.outlineWidthMode){case P.WorldCorrdinates:!0!==e.MTOON_OUTLINE_WIDTH_WORLD&&(e.MTOON_OUTLINE_WIDTH_WORLD=!0,e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.markAsUnprocessed());break;case P.ScreenCoordinates:!0!==e.MTOON_OUTLINE_WIDTH_SCREEN&&(e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.MTOON_OUTLINE_WIDTH_SCREEN=!0,e.markAsUnprocessed());break;case P.None:!1===e.MTOON_OUTLINE_WIDTH_SCREEN&&!1===e.MTOON_OUTLINE_WIDTH_WORLD||(e.MTOON_OUTLINE_WIDTH_SCREEN=!1,e.MTOON_OUTLINE_WIDTH_WORLD=!1,e.markAsUnprocessed())}switch(this.outlineColorMode){case N.FixedColor:!0!==e.MTOON_OUTLINE_COLOR_FIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!0,e.MTOON_OUTLINE_COLOR_MIXED=!1,e.markAsUnprocessed());break;case N.MixedLighting:!0!==e.MTOON_OUTLINE_COLOR_MIXED&&(e.MTOON_OUTLINE_COLOR_FIXED=!1,e.MTOON_OUTLINE_COLOR_MIXED=!0,e.markAsUnprocessed())}}}e([(0,t.serializeAsTexture)("diffuseTexture")],L.prototype,"_diffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],L.prototype,"diffuseTexture",void 0),e([(0,t.serializeAsTexture)("emissiveTexture")],L.prototype,"_emissiveTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"emissiveTexture",void 0),e([(0,t.serializeAsTexture)("bumpTexture")],L.prototype,"_bumpTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"bumpTexture",void 0),e([(0,t.serializeAsTexture)("shadeTexture")],L.prototype,"_shadeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"shadeTexture",void 0),e([(0,t.serializeAsTexture)("receiveShadowTexture")],L.prototype,"_receiveShadowTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"receiveShadowTexture",void 0),e([(0,t.serializeAsTexture)("shadingGradeTexture")],L.prototype,"_shadingGradeTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"shadingGradeTexture",void 0),e([(0,t.serializeAsTexture)("rimTexture")],L.prototype,"_rimTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"rimTexture",void 0),e([(0,t.serializeAsTexture)("matCapTexture")],L.prototype,"_matCapTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"matCapTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],L.prototype,"_outlineWidthTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"outlineWidthTexture",void 0),e([(0,t.serializeAsTexture)("outlineWidthTexture")],L.prototype,"_uvAnimationMaskTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"uvAnimationMaskTexture",void 0),e([(0,t.serializeAsColor3)("diffuse")],L.prototype,"diffuseColor",void 0),e([(0,t.serialize)("ambient")],L.prototype,"ambientColor",void 0),e([(0,t.serialize)("emissive")],L.prototype,"emissiveColor",void 0),e([(0,t.serialize)("shade")],L.prototype,"shadeColor",void 0),e([(0,t.serialize)("rim")],L.prototype,"rimColor",void 0),e([(0,t.serialize)("outline")],L.prototype,"outlineColor",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"useEmissiveAsIllumination",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"linkEmissiveWithDiffuse",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"useReflectionOverAlpha",void 0),e([(0,t.serialize)("disableLighting")],L.prototype,"_disableLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],L.prototype,"disableLighting",void 0),e([(0,t.serialize)()],L.prototype,"alphaCutOff",void 0),e([(0,t.serialize)("useAlphaFromDiffuseTexture")],L.prototype,"_useAlphaFromDiffuseTexture",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesAndMiscDirty")],L.prototype,"useAlphaFromDiffuseTexture",void 0),e([(0,t.serialize)("maxSimultaneousLights")],L.prototype,"_maxSimultaneousLights",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsLightsDirty")],L.prototype,"maxSimultaneousLights",void 0),e([(0,t.serialize)("invertNormalMapX")],L.prototype,"_invertNormalMapX",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"invertNormalMapX",void 0),e([(0,t.serialize)("invertNormalMapY")],L.prototype,"_invertNormalMapY",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"invertNormalMapY",void 0),e([(0,t.serialize)("twoSidedLighting")],L.prototype,"_twoSidedLighting",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsTexturesDirty")],L.prototype,"twoSidedLighting",void 0),e([(0,t.serialize)()],L.prototype,"bumpScale",null),e([(0,t.serialize)()],L.prototype,"receiveShadowRate",null),e([(0,t.serialize)()],L.prototype,"shadingGradeRate",null),e([(0,t.serialize)()],L.prototype,"shadeShift",null),e([(0,t.serialize)()],L.prototype,"shadeToony",null),e([(0,t.serialize)()],L.prototype,"lightColorAttenuation",null),e([(0,t.serialize)()],L.prototype,"indirectLightIntensity",null),e([(0,t.serialize)()],L.prototype,"rimLightingMix",null),e([(0,t.serialize)()],L.prototype,"rimFresnelPower",null),e([(0,t.serialize)()],L.prototype,"rimLift",null),e([(0,t.serialize)()],L.prototype,"outlineWidth",null),e([(0,t.serialize)()],L.prototype,"outlineScaledMaxDistance",null),e([(0,t.serialize)()],L.prototype,"outlineLightingMix",null),e([(0,t.serialize)()],L.prototype,"uvAnimationScrollX",null),e([(0,t.serialize)()],L.prototype,"uvAnimationScrollY",null),e([(0,t.serialize)()],L.prototype,"uvAnimationRotation",null),e([(0,t.serialize)("alphaTest")],L.prototype,"_alphaTest",void 0),e([(0,t.serialize)()],L.prototype,"alphaTest",null),e([(0,t.serialize)()],L.prototype,"alphaBlend",null),e([(0,t.serialize)("debugMode")],L.prototype,"_debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],L.prototype,"debugMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],L.prototype,"outlineColorMode",void 0),e([(0,t.serialize)()],L.prototype,"cullMode",null),e([(0,t.serialize)()],L.prototype,"_outlineCullMode",void 0),e([(0,t.expandToProperty)("_markAllSubMeshesAsMiscDirty")],L.prototype,"outlineCullMode",void 0),e([(0,t.serialize)("flipU")],L.prototype,"flipU",void 0),e([(0,t.serialize)("flipV")],L.prototype,"flipV",void 0),e([(0,t.serialize)()],L.prototype,"useLogarithmicDepth",null)})(),A})(),e.exports=n(i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5),i(5))},5:e=>{"use strict";e.exports=BABYLON}},t={};function i(n){var r=t[n];if(void 0!==r)return r.exports;var o=t[n]={exports:{}};return e[n](o,o.exports,i),o.exports}i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var n={};(()=>{"use strict";i.r(n),i.d(n,{BoneNotFoundError:()=>e,HumanoidBone:()=>t,IVRMMaterialPropertyShader:()=>u,MaterialValueBindingMerger:()=>d,VCAST_vci_material_unity:()=>g,VRM:()=>Y,VRMFileLoader:()=>Q,VRMFileLoaderPlugin:()=>K,VRMManager:()=>L,VRMMaterialGenerator:()=>c});class e extends Error{constructor(e){super(`Bone:${e} NotFound`),this.boneName=e,this.name="BoneNotFoundError"}}class t{constructor(e){this.nodeMap=e}dispose(){this.nodeMap=null}get hips(){return this.getMandatoryBone("hips")}get leftUpperLeg(){return this.getMandatoryBone("leftUpperLeg")}get rightUpperLeg(){return this.getMandatoryBone("rightUpperLeg")}get leftLowerLeg(){return this.getMandatoryBone("leftLowerLeg")}get rightLowerLeg(){return this.getMandatoryBone("rightLowerLeg")}get leftFoot(){return this.getMandatoryBone("leftFoot")}get rightFoot(){return this.getMandatoryBone("rightFoot")}get spine(){return this.getMandatoryBone("spine")}get chest(){return this.getMandatoryBone("chest")}get neck(){return this.getMandatoryBone("neck")}get head(){return this.getMandatoryBone("head")}get leftShoulder(){return this.getMandatoryBone("leftShoulder")}get rightShoulder(){return this.getMandatoryBone("rightShoulder")}get leftUpperArm(){return this.getMandatoryBone("leftUpperArm")}get rightUpperArm(){return this.getMandatoryBone("rightUpperArm")}get leftLowerArm(){return this.getMandatoryBone("leftLowerArm")}get rightLowerArm(){return this.getMandatoryBone("rightLowerArm")}get leftHand(){return this.getMandatoryBone("leftHand")}get rightHand(){return this.getMandatoryBone("rightHand")}get leftToes(){return this.getOptionalBone("leftToes")}get rightToes(){return this.getOptionalBone("rightToes")}get leftEye(){return this.getOptionalBone("leftEye")}get rightEye(){return this.getOptionalBone("rightEye")}get jaw(){return this.getOptionalBone("jaw")}get leftThumbMetacarpal(){return this.getOptionalBone("leftThumbMetacarpal")}get leftThumbProximal(){return this.getOptionalBone("leftThumbProximal")}get leftThumbIntermediate(){return this.getOptionalBone("leftThumbIntermediate")}get leftThumbDistal(){return this.getOptionalBone("leftThumbDistal")}get leftIndexProximal(){return this.getOptionalBone("leftIndexProximal")}get leftIndexIntermediate(){return this.getOptionalBone("leftIndexIntermediate")}get leftIndexDistal(){return this.getOptionalBone("leftIndexDistal")}get leftMiddleProximal(){return this.getOptionalBone("leftMiddleProximal")}get leftMiddleIntermediate(){return this.getOptionalBone("leftMiddleIntermediate")}get leftMiddleDistal(){return this.getOptionalBone("leftMiddleDistal")}get leftRingProximal(){return this.getOptionalBone("leftRingProximal")}get leftRingIntermediate(){return this.getOptionalBone("leftRingIntermediate")}get leftRingDistal(){return this.getOptionalBone("leftRingDistal")}get leftLittleProximal(){return this.getOptionalBone("leftLittleProximal")}get leftLittleIntermediate(){return this.getOptionalBone("leftLittleIntermediate")}get leftLittleDistal(){return this.getOptionalBone("leftLittleDistal")}get rightThumbMetacarpal(){return this.getOptionalBone("rightThumbMetacarpal")}get rightThumbProximal(){return this.getOptionalBone("rightThumbProximal")}get rightThumbIntermediate(){return this.getOptionalBone("rightThumbIntermediate")}get rightThumbDistal(){return this.getOptionalBone("rightThumbDistal")}get rightIndexProximal(){return this.getOptionalBone("rightIndexProximal")}get rightIndexIntermediate(){return this.getOptionalBone("rightIndexIntermediate")}get rightIndexDistal(){return this.getOptionalBone("rightIndexDistal")}get rightMiddleProximal(){return this.getOptionalBone("rightMiddleProximal")}get rightMiddleIntermediate(){return this.getOptionalBone("rightMiddleIntermediate")}get rightMiddleDistal(){return this.getOptionalBone("rightMiddleDistal")}get rightRingProximal(){return this.getOptionalBone("rightRingProximal")}get rightRingIntermediate(){return this.getOptionalBone("rightRingIntermediate")}get rightRingDistal(){return this.getOptionalBone("rightRingDistal")}get rightLittleProximal(){return this.getOptionalBone("rightLittleProximal")}get rightLittleIntermediate(){return this.getOptionalBone("rightLittleIntermediate")}get rightLittleDistal(){return this.getOptionalBone("rightLittleDistal")}get upperChest(){return this.getOptionalBone("upperChest")}getMandatoryBone(t){const i=this.nodeMap[t];if(!i)throw new e(t);return i}getOptionalBone(e){return this.nodeMap&&this.nodeMap[e]||null}}var r=i(5),o=i(731);const a={_MainTex:"albedoTexture"},s={_Color:"albedoColor"},l={_MainTex:"diffuseTexture",_EmissionMap:"emissiveTexture",_BumpMap:"bumpTexture",_ShadeTexture:"shadeTexture",_ReceiveShadowTexture:"receiveShadowTexture",_ShadingGradeTexture:"shadingGradeTexture",_RimTexture:"rimTexture",_SphereAdd:"matCapTexture",_OutlineWidthTexture:"outlineWidthTexture",_UvAnimMaskTexture:"uvAnimationMaskTexture"},h={_Color:"diffuseColor",_ShadeColor:"shadeColor",_RimColor:"rimColor",_EmissionColor:"emissiveColor",_OutlineColor:"outlineColor"};class d{constructor(e,t){this.materialValues=t,this.m_materialMap={},this.m_materialSetterMap={},this.m_materialValueMap={},this.m_used={},this.baseValueCache={},this.materialValuesToApply={},0!==e.length&&0!==t.length&&(e.forEach((e=>{(e instanceof o.MToonMaterial||e instanceof r.PBRMaterial)&&(this.m_materialMap[e.name]=e)})),t.forEach((e=>{const t=this.makeBindingKey(e);if(this.m_materialSetterMap[t])return;const i=this.m_materialMap[e.materialName];if(!i)return;const n=this.getMaterialProperty(i,e.propertyName);if(!n||4!==e.targetValue.length)return;this.baseValueCache[t]=n,this.materialValuesToApply[t]=e;const o=r.Vector4.FromArray(e.targetValue),s=e.propertyName;if(i instanceof r.PBRMaterial?Object.keys(a).some((e=>s.startsWith(e)))&&(o.w*=-1):Object.keys(l).some((e=>s.startsWith(e)))&&(o.w*=-1),s.endsWith("_ST_S")){const e=(e,t)=>{const r=t?n.add(o.subtract(n).scale(e)):this.getMaterialProperty(i,s).add(o.subtract(n).scale(e)),a=this.getMaterialProperty(i,s);a.x=r.x,a.z=r.z,this.updateMaterialProperty(i,s,a)};this.m_materialSetterMap[t]=e}else if(s.endsWith("_ST_T")){const e=(e,t)=>{const r=t?n.add(o.subtract(n).scale(e)):this.getMaterialProperty(i,s).add(o.subtract(n).scale(e)),a=this.getMaterialProperty(i,s);a.y=r.y,a.w=r.w,this.updateMaterialProperty(i,s,a)};this.m_materialSetterMap[t]=e}else{const e=(e,t)=>{const r=t?n.add(o.subtract(n).scale(e)):this.getMaterialProperty(i,s).add(o.subtract(n).scale(e));this.updateMaterialProperty(i,s,r)};this.m_materialSetterMap[t]=e}})))}makeBindingKey(e){return`${e.materialName}_${e.propertyName}_${e.targetValue.join("-")}`}makeTargetKey(e){return`${e.materialName}_${e.propertyName}`}morphing(e){this.accumulateValue(e),this.apply()}accumulateValue(e){this.materialValues.forEach((t=>{const i=this.makeBindingKey(t);this.m_materialValueMap[i]?this.m_materialValueMap[i]+=e:this.m_materialValueMap[i]=e}))}apply(){this.m_used={},Object.entries(this.materialValuesToApply).forEach((([e,t])=>{const i=this.makeTargetKey(t);if(!(i in this.m_used)){const n=this.m_materialMap[t.materialName],r=this.baseValueCache[e].clone(),o=t.propertyName;if(o.endsWith("_ST_S")){const e=this.getMaterialProperty(n,o);r.y=e.y,r.w=e.w}else if(o.endsWith("_ST_T")){const e=this.getMaterialProperty(n,o);r.x=e.x,r.z=e.z}this.updateMaterialProperty(n,o,r),this.m_used[i]=!0}const n=this.m_materialSetterMap[e];n&&n(this.m_materialValueMap[e],!1)})),this.m_materialValueMap={}}getMaterialProperty(e,t){const i=t.match(/^(_[^_]+)/);if(!i||!i[1])return null;const n=i[1];return e instanceof r.PBRMaterial?a[n]?this.convertTextureIntoVector4WhenNotNull(e[a[n]]):s[n]?this.convertColorIntoVector4(e[s[n]],e.alpha):null:l[n]?this.convertTextureIntoVector4WhenNotNull(e[l[n]]):h[n]?this.convertColorIntoVector4(e[h[n]],e.alpha):null}convertTextureIntoVector4WhenNotNull(e){if(!e)return null;const t=e;return new r.Vector4(t.uScale,t.vScale,t.uOffset,t.vOffset)}convertColorIntoVector4(e,t){return new r.Vector4(e.r,e.g,e.b,t)}updateMaterialProperty(e,t,i){const n=t.match(/^(_[^_]+)/);if(!n||!n[1])return;const o=n[1];if(e instanceof r.PBRMaterial)return a[o]?void this.updateTextureWhenNotNull(e[a[o]],i):void(s[o]&&("_Color"===o&&(e.alpha=i.w),this.updateColor(e[s[o]],i)));l[o]?this.updateTextureWhenNotNull(e[l[o]],i):h[o]&&("_Color"===o&&(e.alpha=i.w),this.updateColor(e[h[o]],i))}updateTextureWhenNotNull(e,t){if(e){const i=e;i.uScale=t.x,i.vScale=t.y,i.uOffset=t.z,i.vOffset=t.w}}updateColor(e,t){e.r=t.x,e.g=t.y,e.b=t.z}}const f=LOADERS.GLTF2;var u;!function(e){e.VRM_USE_GLTFSHADER="VRM_USE_GLTFSHADER",e.VRMMToon="VRM/MToon",e.VRMUnlitTransparentZWrite="VRM/UnlitTransparentZWrite"}(u||(u={}));class c{constructor(e){this.loader=e}generate(e,t,i,n,r){const a=this.findMaterialPropertyByName(t.name,this.getMaterialProperties());if(!a)return null;i.alphaIndex=a.renderQueue;const s=this.createMaterialByShader(e,t,n,a);return s?(r(s),s instanceof o.MToonMaterial?this.loadMToonTexturesAsync(e,s,a):Promise.resolve(s)):null}getMaterialProperties(){return this.loader.gltf.extensions?this.loader.gltf.extensions.VRM&&this.loader.gltf.extensions.VRM.materialProperties?this.loader.gltf.extensions.VRM.materialProperties:this.loader.gltf.extensions.VCAST_vci_material_unity&&this.loader.gltf.extensions.VCAST_vci_material_unity.materials?this.loader.gltf.extensions.VCAST_vci_material_unity.materials:[]:[]}findMaterialPropertyByName(e,t){if(!e||!t)return null;const i=t.filter((t=>t.name===e));return 0===i.length?null:(i.length>=2&&this.loader.log(`Duplicated vrm material name found: ${e}`),i[i.length-1])}loadMToonTexturesAsync(e,t,i){const n=[],r=i.vectorProperties._MainTex;if(!r)return Promise.resolve(t);const o=(t,i)=>{m(t,(o=>{n.push(this.loader.loadTextureInfoAsync(`${e}/textures/${t}`,{index:o},(e=>{const t=e;t.uOffset=r[0],t.vOffset=r[1],t.uScale=r[2],t.vScale=r[3],i(e)})))}))};return o(i.textureProperties._MainTex,(e=>{(t.alphaBlend||t.alphaTest)&&(e.hasAlpha=!0),t.diffuseTexture=e})),o(i.textureProperties._ShadeTexture,(e=>t.shadeTexture=e)),o(i.textureProperties._BumpMap,(e=>t.bumpTexture=e)),o(i.textureProperties._ReceiveShadowTexture,(e=>t.receiveShadowTexture=e)),o(i.textureProperties._ShadingGradeTexture,(e=>t.shadingGradeTexture=e)),o(i.textureProperties._RimTexture,(e=>t.rimTexture=e)),o(i.textureProperties._SphereAdd,(e=>t.matCapTexture=e)),o(i.textureProperties._EmissionMap,(e=>t.emissiveTexture=e)),o(i.textureProperties._OutlineWidthTexture,(e=>t.outlineWidthTexture=e)),o(i.textureProperties._UvAnimMaskTexture,(e=>t.uvAnimationMaskTexture=e)),Promise.all(n).then((()=>t))}createMaterialByShader(e,t,i,n){if(n.shader===u.VRMMToon){const e=new o.MToonMaterial(t.name||`MToonMaterial${t.index}`,this.loader.babylonScene);return this.setMToonMaterialProperties(e,n),e}if(n.shader===u.VRMUnlitTransparentZWrite){const n=this.loader.createMaterial(e,t,i);return n.disableDepthWrite=!1,n.forceDepthWrite=!0,n}return null}setMToonMaterialProperties(e,t){m(t.floatProperties._Cutoff,(t=>e.alphaCutOff=t)),m(t.vectorProperties._Color,(t=>{e.diffuseColor=new r.Color3(t[0],t[1],t[2]),e.alpha=t[3]})),m(t.vectorProperties._ShadeColor,(t=>{e.shadeColor=new r.Color3(t[0],t[1],t[2])})),m(t.floatProperties._BumpScale,(t=>e.bumpScale=t)),m(t.floatProperties._ReceiveShadowRate,(t=>e.receiveShadowRate=t)),m(t.floatProperties._ShadingGradeRate,(t=>e.shadingGradeRate=t)),m(t.floatProperties._ShadeShift,(t=>e.shadeShift=t)),m(t.floatProperties._ShadeToony,(t=>e.shadeToony=t)),m(t.floatProperties._LightColorAttenuation,(t=>e.lightColorAttenuation=t)),m(t.floatProperties._IndirectLightIntensity,(t=>e.indirectLightIntensity=t)),m(t.vectorProperties._RimColor,(t=>{e.rimColor=new r.Color3(t[0],t[1],t[2])})),m(t.floatProperties._RimLightingMix,(t=>e.rimLightingMix=t)),m(t.floatProperties._RimFresnelPower,(t=>e.rimFresnelPower=t)),m(t.floatProperties._RimLift,(t=>e.rimLift=t)),m(t.vectorProperties._EmissionColor,(t=>{e.emissiveColor=new r.Color3(t[0],t[1],t[2])})),m(t.floatProperties._OutlineWidth,(t=>e.outlineWidth=t)),m(t.floatProperties._OutlineScaledMaxDistance,(t=>e.outlineScaledMaxDistance=t)),m(t.vectorProperties._OutlineColor,(t=>{e.outlineColor=new r.Color3(t[0],t[1],t[2])})),m(t.floatProperties._OutlineLightingMix,(t=>e.outlineLightingMix=t)),m(t.floatProperties._UvAnimScrollX,(t=>e.uvAnimationScrollX=t)),m(t.floatProperties._UvAnimScrollY,(t=>e.uvAnimationScrollY=t)),m(t.floatProperties._UvAnimRotation,(t=>e.uvAnimationRotation=t)),m(t.floatProperties._DebugMode,(t=>e.debugMode=t)),m(t.floatProperties._BlendMode,(t=>{switch(t){case 0:e.alphaBlend=!1,e.alphaTest=!1;break;case 1:e.alphaBlend=!1,e.alphaTest=!0,e.alphaMode=r.Engine.ALPHA_COMBINE;break;case 2:e.alphaBlend=!0,e.alphaTest=!1,e.alphaMode=r.Engine.ALPHA_COMBINE}})),m(t.floatProperties._OutlineWidthMode,(t=>e.outlineWidthMode=t)),m(t.floatProperties._OutlineColorMode,(t=>e.outlineColorMode=t)),m(t.floatProperties._CullMode,(t=>e.cullMode=t)),m(t.floatProperties._OutlineCullMode,(t=>e.outlineCullMode=t)),m(t.keywordMap._ALPHABLEND_ON,(t=>e.alphaBlend=t)),m(t.keywordMap._ALPHATEST_ON,(t=>e.alphaTest=t)),m(t.floatProperties._ZWrite,(t=>{e.forceDepthWrite=1===Math.round(t),e.forceDepthWrite&&(e.disableDepthWrite=!1)}))}}function m(e,t){void 0!==e&&t(e)}const p="VCAST_vci_material_unity";class g{constructor(e){this.loader=e,this.name=p,this.enabled=!0}dispose(){this.loader=null}_loadMaterialAsync(e,t,i,n,r){return new c(this.loader).generate(e,t,i,n,r)}}f.GLTFLoader.RegisterExtension(p,(e=>new g(e)));class M{constructor(e,t,i){this.offset=e,this.radius=t,this.sphere=i}}class _{constructor(e){this.transform=e,this.colliders=[]}addCollider(e,t){const i=r.SphereBuilder.CreateSphere(`${this.transform.name}_ColliderSphere`,{segments:6,diameter:2*t,updatable:!0},this.transform.getScene());i.setParent(this.transform),i.setPositionWithLocalVector(e),i.setEnabled(!1),this.colliders.push(new M(e,t,i))}}const T=r.Matrix.Identity(),v=new r.Vector3,I=new r.Vector3,A=new r.Vector3,S=new r.Quaternion,E=new r.Matrix,x=new r.Matrix;class N{constructor(e,t,i){this.center=e,this.radius=t,this.transform=i,this.currentTail=new r.Vector3,this.prevTail=new r.Vector3,this.nextTail=new r.Vector3,i.rotationQuaternion||(i.rotationQuaternion=i.rotation.toQuaternion());const n=i.getWorldMatrix();this.centerSpacePosition=n.getTranslation(),this.initialLocalMatrix=i._localMatrix.clone(),this.initialLocalRotation=i.rotationQuaternion.clone();const o=i.getChildTransformNodes(!0);0===o.length?this.initialLocalChildPosition=i.position.clone().normalize().scaleInPlace(.07):this.initialLocalChildPosition=o[0].position.clone(),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,n,this.currentTail),this.prevTail.copyFrom(this.currentTail),this.nextTail.copyFrom(this.currentTail),this.boneAxis=this.initialLocalChildPosition.normalizeToNew(),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,n,v),this.centerSpaceBoneLength=v.subtractInPlace(this.centerSpacePosition).length(),e&&(this.getMatrixWorldToCenter(E),r.Vector3.TransformCoordinatesToRef(this.currentTail,E,this.currentTail),r.Vector3.TransformCoordinatesToRef(this.prevTail,E,this.prevTail),r.Vector3.TransformCoordinatesToRef(this.nextTail,E,this.nextTail),n.multiplyToRef(E,E),E.getTranslationToRef(this.centerSpacePosition),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,E,v),this.centerSpaceBoneLength=v.subtractInPlace(this.centerSpacePosition).length())}update(e,t,i,n){if(Number.isNaN(this.transform.getAbsolutePosition().x))return;this.getMatrixWorldToCenter(E),this.transform.getWorldMatrix().multiplyToRef(E,E),E.getTranslationToRef(this.centerSpacePosition),this.getMatrixWorldToCenter(x),this.getParentMatrixWorld().multiplyToRef(x,x),this.nextTail.copyFrom(this.currentTail),v.copyFrom(this.currentTail).subtractInPlace(this.prevTail).scaleInPlace(1-t),this.nextTail.addInPlace(v),v.copyFrom(this.boneAxis),r.Vector3.TransformCoordinatesToRef(v,this.initialLocalMatrix,v),r.Vector3.TransformCoordinatesToRef(v,x,v),v.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(e),this.nextTail.addInPlace(v),this.nextTail.addInPlace(i),this.nextTail.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition),this.collide(n,this.nextTail),this.prevTail.copyFrom(this.currentTail),this.currentTail.copyFrom(this.nextTail),this.initialLocalMatrix.multiplyToRef(x,E);const o=E.invert();r.Vector3.TransformCoordinatesToRef(this.nextTail,o,v),v.normalizeToRef(I),r.Quaternion.FromUnitVectorsToRef(this.boneAxis,I,S);const a=S;this.initialLocalRotation.multiplyToRef(a,this.transform.rotationQuaternion),this.transform.computeWorldMatrix(!0)}getMatrixWorldToCenter(e){return this.center?this.center.getWorldMatrix().invertToRef(e):e.copyFrom(T),e}getParentMatrixWorld(){return this.transform.parent?this.transform.parent.getWorldMatrix():T}collide(e,t){e.forEach((e=>{e.colliders.forEach((e=>{this.getMatrixWorldToCenter(E),e.sphere.computeWorldMatrix().multiplyToRef(E,E),E.getTranslationToRef(v);const i=v;let n=0;e.sphere.absoluteScaling.asArray().forEach((e=>{n=Math.max(n,Math.abs(e))}));const r=e.radius*n,o=this.radius+r;if(t.subtractToRef(i,I),I.lengthSquared()<=o*o){const e=I.copyFrom(t).subtractInPlace(i).normalize(),n=A.copyFrom(i).addInPlace(e.scaleInPlace(o));t.copyFrom(n.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition))}}))}))}}class P{constructor(e,t,i,n,r,o,a,s,l){this.comment=e,this.stiffness=t,this.gravityPower=i,this.gravityDir=n,this.dragForce=r,this.center=o,this.hitRadius=a,this.bones=s,this.colliderGroups=l,this.verlets=[],this.activeBones=[],this.drawGizmo=!1,this.activeBones=this.bones.filter((e=>null!==e)),this.activeBones.forEach((e=>{[e].concat(e.getChildTransformNodes()).forEach((e=>{this.verlets.push(new N(this.center,this.hitRadius,e))}))})),this.drawGizmo&&this.setupGizmo()}setupGizmo(){this.activeBones.forEach((e=>{const t=e.getScene();[e].concat(e.getChildTransformNodes()).forEach((e=>{const i=r.MeshBuilder.CreateSphere(e.name+"_boneGizmo",{segments:6,diameter:2*this.hitRadius,updatable:!0},t),n=new r.StandardMaterial(e.name+"_boneGizmomat",t);n.emissiveColor=r.Color3.Red(),n.wireframe=!0,i.material=n,i.setParent(e),i.position=r.Vector3.Zero()}))})),this.colliderGroups.forEach((e=>{const t=e.transform.getScene();e.colliders.forEach((i=>{const n=i.sphere;if(!n.isEnabled(!1)){n.setEnabled(!0);const i=new r.StandardMaterial(e.transform.name+"_colliderGizmomat",t);i.emissiveColor=r.Color3.Yellow(),i.wireframe=!0,n.material=i}}))}))}async update(e){const t=this.stiffness*e,i=this.gravityDir.scale(this.gravityPower*e),n=this.verlets.map((e=>new Promise((n=>{e.update(t,this.dragForce,i,this.colliderGroups),n()}))));return Promise.all(n).then((()=>{}))}}class C{constructor(e,t){this.ext=e;const i=this.constructColliderGroups(t);this.springs=this.constructSprings(t,i)}dispose(){this.springs=[]}async update(e){e=Math.max(0,Math.min(16.666,e))/1e3;const t=this.springs.map((t=>t.update(e)));return Promise.all(t).then((()=>{}))}constructColliderGroups(e){if(!this.ext||!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const t=[];return this.ext.colliderGroups.forEach((i=>{const n=e(i.node),o=new _(n);i.colliders.forEach((e=>{o.addCollider(new r.Vector3(-e.offset.x,e.offset.y,-e.offset.z),e.radius)})),t.push(o)})),t}constructSprings(e,t){if(!this.ext||!this.ext.boneGroups||!this.ext.boneGroups.length)return[];const i=[];return this.ext.boneGroups.forEach((n=>{const o=(n.bones||[]).map((t=>e(t))),a=(n.colliderGroups||[]).map((e=>t[e]));i.push(new P(n.comment,n.stiffiness,n.gravityPower,new r.Vector3(-n.gravityDir.x,n.gravityDir.y,-n.gravityDir.z).normalize(),n.dragForce,e(n.center),n.hitRadius,o,a))})),i}}class L{constructor(e,i,n,r,o){this.ext=e,this.scene=i,this.meshesFrom=n,this.transformNodesFrom=r,this.materialsNodesFrom=o,this.isBinaryMorphMap={},this.morphTargetMap={},this.materialValueBindingMergerMap={},this.presetMorphTargetMap={},this.transformNodeMap={},this.transformNodeCache={},this.meshCache={},this.meshCache=this.constructMeshCache(),this.transformNodeCache=this.constructTransformNodeCache(),this.ext.secondaryAnimation&&(this.springBoneController=new C(this.ext.secondaryAnimation,this.findTransformNode.bind(this))),this.ext.blendShapeMaster&&this.ext.blendShapeMaster.blendShapeGroups&&(this.constructIsBinaryMap(),this.constructMorphTargetMap(),this.constructMaterialValueBindingMergerMap()),this.constructTransformNodeMap(),this._humanoidBone=new t(this.transformNodeMap)}async update(e){this.springBoneController&&await this.springBoneController.update(e)}dispose(){this.springBoneController.dispose(),this._humanoidBone.dispose(),this.morphTargetMap=null,this.materialValueBindingMergerMap=null,this.presetMorphTargetMap=null,this.transformNodeMap=null,this.transformNodeCache=null,this.meshCache=null,this._rootMesh=null}morphing(e,t){const i=this.calcMorphValue(e,t);this.morphTargetMap[e]&&this.morphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)})),this.materialValueBindingMergerMap[e]&&this.materialValueBindingMergerMap[e].morphing(i)}morphingPreset(e,t){if(!this.presetMorphTargetMap[e])return;const i=this.calcMorphValue(e,t);this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/100)}))}calcMorphValue(e,t){const i=Math.max(0,Math.min(1,t));return this.isBinaryMorphMap[e]?i>.5?1:0:i}getMorphingList(){return Object.keys(this.morphTargetMap)}getFirstPersonCameraPosition(){const e=this.getFirstPersonBone();if(!e)return null;const t=e.getAbsolutePosition(),i=this.ext.firstPerson.firstPersonBoneOffset;return new r.Vector3(t.x+i.x,t.y+i.y,t.z+i.z)}getFirstPersonBone(){return this.findTransformNode(this.ext.firstPerson.firstPersonBone)}getBone(e){return this.transformNodeMap[e]||null}get humanoidBone(){return this._humanoidBone}get rootMesh(){return this._rootMesh}findTransformNode(e){return this.transformNodeCache[e]||null}findMesh(e){return this.meshCache[e]&&this.meshCache[e][0]||null}findMeshes(e){return this.meshCache[e]||null}constructIsBinaryMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{this.isBinaryMorphMap[e.name]=e.isBinary}))}constructMorphTargetMap(){this.ext.blendShapeMaster.blendShapeGroups.forEach((e=>{e.binds&&e.binds.forEach((t=>{const i=this.findMeshes(t.mesh);i?i.forEach((i=>{const n=i.morphTargetManager;if(!n)return void console.log("Undefined morphTargetManager",t);const r=n.getTarget(t.index);this.morphTargetMap[e.name]=this.morphTargetMap[e.name]||[],this.morphTargetMap[e.name].push({target:r,weight:t.weight}),e.presetName&&(this.presetMorphTargetMap[e.presetName]=this.presetMorphTargetMap[e.presetName]||[],this.presetMorphTargetMap[e.presetName].push({target:r,weight:t.weight}))})):console.log("Undefined BlendShapeBind Mesh",t)}))}))}constructMaterialValueBindingMergerMap(){const e=this.scene.materials.slice(this.materialsNodesFrom);this.ext.blendShapeMaster.blendShapeGroups.forEach((t=>{t.materialValues&&(this.materialValueBindingMergerMap[t.name]=new d(e,t.materialValues))}))}constructTransformNodeMap(){this.ext.humanoid.humanBones.forEach((e=>{const t=this.findTransformNode(e.node);t&&(this.transformNodeMap[e.bone]=t)}))}constructTransformNodeCache(){const e={};for(let t=this.transformNodesFrom;t<this.scene.transformNodes.length;t++){const i=this.scene.transformNodes[t];if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length||(i.metadata=i._internalMetadata),i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers)if(t.startsWith("/nodes/")){e[parseInt(t.substr(7),10)]=i;break}}return e}constructMeshCache(){const e={};for(let t=this.meshesFrom;t<this.scene.meshes.length;t++){const i=this.scene.meshes[t];if("__root__"!==i.id){if(i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length||(i.metadata=i._internalMetadata),i&&i.metadata&&i.metadata.gltf&&i.metadata.gltf.pointers&&0!==i.metadata.gltf.pointers.length)for(const t of i.metadata.gltf.pointers){const n=t.match(/^\/meshes\/(\d+).+$/);if(n){const t=parseInt(n[1],10);e[t]=e[t]||[],e[t].push(i);break}}}else this._rootMesh=i}return e}}class D{constructor(e,t,i,n,r,o){this.offset=e,this.tail=t,this.radius=i,this.sphere=n,this.sphereTail=r,this.transform=o}}class R{constructor(){this.colliders=[]}addCollider(e,t,i,n){const o=r.SphereBuilder.CreateSphere(`${n.name}_ColliderSphere`,{segments:6,diameter:2*i,updatable:!0},n.getScene());o.setParent(n),o.position=e,o.setEnabled(!1);let a=null;t&&(a=r.SphereBuilder.CreateSphere(`${n.name}_ColliderSphereTail`,{segments:6,diameter:2*i,updatable:!0},n.getScene()),a.setParent(n),a.position=t,a.setEnabled(!1)),this.colliders.push(new D(e,t,i,o,a,n))}}const O=r.Matrix.Identity(),y=new r.Vector3,b=new r.Vector3,w=new r.Vector3,F=new r.Quaternion,X=new r.Matrix,U=new r.Matrix;class V{constructor(e,t,i,n){this.center=e,this.radius=t,this.transform=i,this.joint=n,this.currentTail=new r.Vector3,this.prevTail=new r.Vector3,this.nextTail=new r.Vector3,i.rotationQuaternion||(i.rotationQuaternion=i.rotation.toQuaternion());const o=i.getWorldMatrix();this.centerSpacePosition=o.getTranslation(),this.initialLocalMatrix=i._localMatrix.clone(),this.initialLocalRotation=i.rotationQuaternion.clone();const a=i.getChildTransformNodes(!0);0===a.length?this.initialLocalChildPosition=i.position.clone().normalize().scaleInPlace(.07):this.initialLocalChildPosition=a[0].position.clone(),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,o,this.currentTail),this.prevTail.copyFrom(this.currentTail),this.nextTail.copyFrom(this.currentTail),this.boneAxis=this.initialLocalChildPosition.normalizeToNew(),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,o,y),this.centerSpaceBoneLength=y.subtractInPlace(this.centerSpacePosition).length(),e&&(this.getMatrixWorldToCenter(X),r.Vector3.TransformCoordinatesToRef(this.currentTail,X,this.currentTail),r.Vector3.TransformCoordinatesToRef(this.prevTail,X,this.prevTail),r.Vector3.TransformCoordinatesToRef(this.nextTail,X,this.nextTail),o.multiplyToRef(X,X),X.getTranslationToRef(this.centerSpacePosition),r.Vector3.TransformCoordinatesToRef(this.initialLocalChildPosition,X,y),this.centerSpaceBoneLength=y.subtractInPlace(this.centerSpacePosition).length())}update(e,t){if(!(this.joint&&this.joint.setting&&this.joint.setting.stiffness&&this.joint.setting.gravityDir&&this.joint.setting.gravityPower&&this.joint.setting.dragForce))return;const i=this.joint.setting.stiffness*t,n=this.joint.setting.gravityDir.scale(this.joint.setting.gravityPower*t),o=i,a=this.joint.setting.dragForce;if(Number.isNaN(this.transform.getAbsolutePosition().x))return;this.getMatrixWorldToCenter(X),this.transform.getWorldMatrix().multiplyToRef(X,X),X.getTranslationToRef(this.centerSpacePosition),this.getMatrixWorldToCenter(U),this.getParentMatrixWorld().multiplyToRef(U,U),this.nextTail.copyFrom(this.currentTail),y.copyFrom(this.currentTail).subtractInPlace(this.prevTail).scaleInPlace(1-a),this.nextTail.addInPlace(y),y.copyFrom(this.boneAxis),r.Vector3.TransformCoordinatesToRef(y,this.initialLocalMatrix,y),r.Vector3.TransformCoordinatesToRef(y,U,y),y.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(o),this.nextTail.addInPlace(y),this.nextTail.addInPlace(n),this.nextTail.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition),this.collide(e,this.nextTail),this.prevTail.copyFrom(this.currentTail),this.currentTail.copyFrom(this.nextTail),this.initialLocalMatrix.multiplyToRef(U,X);const s=X.invert();r.Vector3.TransformCoordinatesToRef(this.nextTail,s,y),y.normalizeToRef(b),r.Quaternion.FromUnitVectorsToRef(this.boneAxis,b,F);const l=F;this.initialLocalRotation.multiplyToRef(l,this.transform.rotationQuaternion),this.transform.computeWorldMatrix(!0)}getMatrixWorldToCenter(e){return this.center?this.center.getWorldMatrix().invertToRef(e):e.copyFrom(O),e}getParentMatrixWorld(){return this.transform.parent?this.transform.parent.getWorldMatrix():O}collide(e,t){e.forEach((e=>{e.colliders.forEach((e=>{e.sphere&&this.collideSphere(e,t)||e.sphereTail&&this.collideCapsule(e,t)}))}))}collideSphere(e,t){this.getMatrixWorldToCenter(X),e.sphere.computeWorldMatrix().multiplyToRef(X,X),X.getTranslationToRef(y);const i=y;let n=0;e.sphere.absoluteScaling.asArray().forEach((e=>{n=Math.max(n,Math.abs(e))}));const r=e.radius*n,o=(this.radius?this.radius:.1)+r;if(t.subtractToRef(i,b),b.lengthSquared()<=o*o){const e=b.copyFrom(t).subtractInPlace(i).normalize(),n=w.copyFrom(i).addInPlace(e.scaleInPlace(o));t.copyFrom(n.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition))}return b.lengthSquared()<=o*o}collideCapsule(e,t){this.getMatrixWorldToCenter(X),e.sphere.computeWorldMatrix().multiplyToRef(X,X),X.getTranslationToRef(y);const i=y;let n=0;e.sphere.absoluteScaling.asArray().forEach((e=>{n=Math.max(n,Math.abs(e))}));const r=e.radius*n,o=(this.radius?this.radius:.1)+r;if(t.subtractToRef(i,b),b.lengthSquared()<=o*o){const e=b.copyFrom(t).subtractInPlace(i).normalize(),n=w.copyFrom(i).addInPlace(e.scaleInPlace(o));t.copyFrom(n.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition))}else if(e.sphereTail){this.getMatrixWorldToCenter(X),e.sphere.computeWorldMatrix().multiplyToRef(X,X),X.getTranslationToRef(y);const i=y;let n=0;e.sphereTail.absoluteScaling.asArray().forEach((e=>{n=Math.max(n,Math.abs(e))}));const r=e.radius*n,o=(this.radius?this.radius:.1)+r;if(t.subtractToRef(i,b),b.lengthSquared()<=o*o){const e=b.copyFrom(t).subtractInPlace(i).normalize(),n=w.copyFrom(i).addInPlace(e.scaleInPlace(o));t.copyFrom(n.subtractInPlace(this.centerSpacePosition).normalize().scaleInPlace(this.centerSpaceBoneLength).addInPlace(this.centerSpacePosition))}}return b.lengthSquared()<=o*o}}class W{constructor(e,t,i,n){this.comment=e,this.center=t,this.joints=i,this.colliderGroups=n,this.verlets=[],this.joints.forEach((e=>{e&&e.child&&this.verlets.push(new V(this.center,e.setting.hitRadius,e.child,e))}))}async update(e){const t=this.verlets.map((t=>new Promise((i=>{t.update(this.colliderGroups,e),i()}))));return Promise.all(t).then((()=>{}))}}class B{constructor(e,t,i,n){this.node=e,this.child=t,this.setting=i,this.colliderGroupsForSpring=n}}class G{constructor(e,t,i,n,r){this.hitRadius=e,this.dragForce=t,this.gravityPower=i,this.stiffness=n,this.gravityDir=r}}class H{constructor(e,t,i){this.ext=e;const n=this.constructColliderGroups(t,i);this.springs=this.constructSprings(t,i,n)}dispose(){this.springs=[]}async update(e){e=Math.max(0,Math.min(16.666,e))/1e3;const t=this.springs.map((t=>t.update(e)));return Promise.all(t).then((()=>{}))}constructColliderGroups(e,t){if(!this.ext||!this.ext.colliderGroups||!this.ext.colliderGroups.length)return[];const i=[];return this.ext.colliderGroups.forEach((t=>{const n=new R;t.colliders.forEach((t=>{let i=this.ext.colliders[t];const o=e(i.node);let a=null,s=null,l=i.shape.sphere;if(l)a=new r.Vector3(l.offset[0],l.offset[1],l.offset[2]);else{if(l=i.shape.capsule,!l)return;a=new r.Vector3(l.offset[0],l.offset[1],l.offset[2]),s=new r.Vector3(l.tail[0],l.tail[1],l.tail[2])}n.addCollider(a,s,l.radius,o)})),i.push(n)})),i}constructSprings(e,t,i){if(!this.ext||!this.ext.springs||!this.ext.springs.length)return[];const n=[];return this.ext.springs.forEach((t=>{const o=(t.colliderGroups||[]).map((e=>i[e]));let a=t,s=t.joints,l=o;const h=null!=a.center?e(a.center):void 0;let d,f=[];s.forEach((t=>{if(d){const i=d.node,n=e(i),o=t.node,a=e(o),s=new G(null!=d.hitRadius?d.hitRadius:.5,null!=d.dragForce?d.dragForce:.5,null!=d.gravityPower?d.gravityPower:1,null!=d.stiffness?d.stiffness:.5,null!=d.gravityDir?r.Vector3.FromArray(d.gravityDir):new r.Vector3(0,-1,0)),u=this._importJoint(n,a,s,l);h&&(u.center=h),f.push(u)}d=t})),n.push(new W(t.name,h,f,o))})),n}_importJoint(e,t,i,n){return new B(e,t,i,n)}}class z extends L{constructor(e,i,n,r,o,a){super({},n,r,o,a),this.ext10=e,this.extSpringBone=i,this.scene=n,this.meshesFrom=r,this.transformNodesFrom=o,this.materialsNodesFrom=a,this.ext10.expressions&&this.ext10.expressions.preset&&(this.constructIsBinaryMap(),this.constructMorphTargetMap(),this.constructMaterialValueBindingMergerMap()),this.constructTransformNodeMap(),this._humanoidBone=new t(this.transformNodeMap),this.springBoneController10=new H(this.extSpringBone,this.findTransformNode.bind(this),this.getBone.bind(this))}async update(e){this.springBoneController10&&await this.springBoneController10.update(e)}constructIsBinaryMap(){if(this.ext10)for(let e of Object.keys(this.ext10.expressions.preset)){let t=this.ext10.expressions.preset[e];if(!t)return;this.isBinaryMorphMap[e]=t.isBinary}}constructMorphTargetMap(){this.ext10&&Object.keys(this.ext10.expressions.preset).forEach((e=>{let t=this.ext10.expressions.preset[e];if(!t)return;if(!t.morphTargetBinds)return;let i=e,n=e;t.morphTargetBinds.forEach((e=>{const t=this.findMeshes(e.node);t?t.forEach((t=>{const r=t.morphTargetManager;if(!r)return void console.log("Undefined morphTargetManager",e);const o=r.getTarget(e.index);this.morphTargetMap[i]=this.morphTargetMap[i]||[],this.morphTargetMap[i].push({target:o,weight:e.weight}),n&&(this.presetMorphTargetMap[n]=this.presetMorphTargetMap[n]||[],this.presetMorphTargetMap[n].push({target:o,weight:e.weight}))})):console.log("Undefined BlendShapeBind Mesh",e)}))}))}constructMaterialValueBindingMergerMap(){this.ext10}constructTransformNodeMap(){if(this.ext10)for(let e of Object.keys(this.ext10.humanoid.humanBones)){let t=this.ext10.humanoid.humanBones[e];if(!t)return;const i=this.findTransformNode(t.node);if(!i)return;this.transformNodeMap[e]=i}}morphingPreset(e,t){if(!this.presetMorphTargetMap[e])return;const i=this.calcMorphValue(e,t);this.presetMorphTargetMap[e].forEach((e=>{e.target.influence=i*(e.weight/1)}))}}class k{constructor(e,t,i){this.ext=e,this.loader=t,this.scene=i,this.humanoidMap=new Map,this.expressionMap=new Map,this.lookAtIndex=-1,this.animationMap=new Map,this.translationMap=new Map,this.rotationMap=new Map,this.parentMap=new Map,this.constructIndex(),this.constructAnimation()}constructIndex(){this.ext&&this.ext.humanoid&&this.ext.humanoid.humanBones&&(Object.keys(this.ext.humanoid.humanBones).forEach((e=>{let t=this.ext.humanoid.humanBones[e];t&&this.humanoidMap.set(t.node,e)})),Object.keys(this.ext.humanoid.humanBones).forEach((e=>{let t=this.ext.humanoid.humanBones[e];if(!t)return;if(!this.loader.gltf||!this.loader.gltf.nodes)return;let i=this.loader.gltf.nodes[t.node];if(i){if(i.children&&i.children.forEach((t=>{let n=this.humanoidMap.get(t);n?this.parentMap.set(n,e):console.log("unexists child",e,i,t)})),i.rotation){let t=r.Quaternion.FromArray(i.rotation);this.rotationMap.set(e,t)}if(i.translation){let t=r.Vector3.FromArray(i.translation);this.translationMap.set(e,t)}}}))),this.ext&&this.ext.expressions&&this.ext.expressions.preset&&Object.keys(this.ext.expressions.preset).forEach((e=>{let t=this.ext.expressions.preset[e];t&&this.expressionMap.set(t.node,e)})),this.ext.lookAt&&void 0!==this.ext.lookAt.node&&(this.lookAtIndex=this.ext.lookAt.node)}constructAnimation(){this.loader.gltf&&this.loader.gltf.animations&&!(this.loader.gltf.animations.length<=0)&&this.loader.gltf.animations[0].channels&&this.loader.gltf.animations[0].channels.forEach((e=>{if(void 0===e.target.node)return;let t=this.humanoidMap.get(e.target.node);t?this.animationMap.set(e.index,t):console.log("skip bone",e.target.node)}))}}class Y{constructor(e){this.loader=e,this.name="VRM",this.enabled=!0,this.meshesFrom=0,this.transformNodesFrom=0,this.materialsFrom=0,this.meshesFrom=this.loader.babylonScene.meshes.length-1,this.transformNodesFrom=this.loader.babylonScene.transformNodes.length,this.materialsFrom=this.loader.babylonScene.materials.length}dispose(){this.loader=null}onReady(){if(!this.loader.gltf.extensions||!this.loader.gltf.extensions.VRM&&!this.loader.gltf.extensions.VRMC_vrm&&!this.loader.gltf.extensions.VRMC_vrm_animation)return;const e=this.loader.babylonScene;if(this.loader.gltf.extensions.VRM){let t=new L(this.loader.gltf.extensions.VRM,this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,this.materialsFrom);e.metadata=e.metadata||{},e.metadata.vrmManagers=e.metadata.vrmManagers||[],e.metadata.vrmManagers.push(t),this.loader.babylonScene.onDisposeObservable.add((()=>{t.dispose(),this.loader.babylonScene.metadata.vrmManagers=[]}))}else if(this.loader.gltf.extensions.VRMC_vrm){let t=new z(this.loader.gltf.extensions.VRMC_vrm,this.loader.gltf.extensions.VRMC_springBone,this.loader.babylonScene,this.meshesFrom,this.transformNodesFrom,this.materialsFrom);e.metadata=e.metadata||{},e.metadata.vrmManagers=e.metadata.vrmManagers||[],e.metadata.vrmManagers.push(t),this.loader.babylonScene.onDisposeObservable.add((()=>{t.dispose(),this.loader.babylonScene.metadata.vrmManagers=[]}))}else if(this.loader.gltf.extensions.VRMC_vrm_animation){let t=new k(this.loader.gltf.extensions.VRMC_vrm_animation,this.loader,this.loader.babylonScene);return e.metadata=e.metadata||{},e.metadata.vrmAnimationManagers=e.metadata.vrtAnimationManagers||[],void e.metadata.vrmAnimationManagers.push(t)}}_loadVertexDataAsync(e,t,i){return t.extras&&t.extras.targetNames?(i.metadata=i.metadata||{},i.metadata.vrmTargetNames=t.extras.targetNames,null):null}_loadMaterialAsync(e,t,i,n,r){return new c(this.loader).generate(e,t,i,n,r)}}f.GLTFLoader.RegisterExtension("VRM",(e=>new Y(e)));const j=LOADERS;class Q extends j.GLTFFileLoader{}class K{constructor(){this.name="vrm",this.extensions={".vrm":{isBinary:!0},".vrma":{isBinary:!0},".vci":{isBinary:!0}}}createPlugin(){return new Q}}r.SceneLoader&&r.SceneLoader.RegisterPlugin(new K)})(),window.VRMLoader=n})();